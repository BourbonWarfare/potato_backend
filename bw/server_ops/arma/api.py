import os
import logging
import shutil
import dataclasses
from pathlib import Path
from collections.abc import Collection
from collections.abc import Callable, Awaitable
from collections.abc import Iterable
from bw.server_ops.arma.server import Server, SERVER_MAP, load_server_config_directory
from bw.server_ops.arma.server_status import ServerStatus, ServerState
from bw.server_ops.arma.mod import (
    Kind,
    Mod,
    MODS,
    MODLISTS,
    fetch_mod_details_from_workshop,
    WorkshopId,
    SteamWorkshopDetails,
    load_modlists,
    load_mods,
    Modlist,
)
from bw.server_ops.arma.mod_store import ModStore
from bw.subprocess.a3sb import a3sb
from bw.subprocess.server_manage import server_manage, ServerResult
from bw.subprocess.steam import steam
from bw.subprocess.command import Chain
from bw.error import (
    BwServerError,
    ServerConfigNotFound,
    DuplicateModWorkshopID,
    ModMissingField,
    ModInvalidKind,
    ModAlreadyDefined,
    ModNotDefined,
)
from bw.settings import GLOBAL_CONFIGURATION
from bw.response import WebResponse, Ok, JsonResponse, Created
from bw.web_utils import define_async_api, define_api
from bw.state import State


logger = logging.getLogger('bw.server_ops.arma')


class ArmaApi:
    @define_api
    def get_all_servers(self) -> JsonResponse:
        """
        ### Retrieve all configured servers

        *Docstring generated by AI.*

        Returns a list of all server names currently configured in the global SERVER_MAP
        dictionary. This provides an inventory of all Arma servers that the backend knows
        about and can manage. Server names are returned in the order they appear in the
        configuration.

        **Async:** No

        **Args:**
        None

        **Returns:**
        - `JsonResponse`: A JSON response containing a list of all server names.

        **Example:**
        ```python
            response = arma_api.get_all_servers()
            # JsonResponse({
            #     'servers': ['Main Server', 'Offnight', 'Staging']
            # })
        ```
        """
        logger.info('Retrieving all configured servers')
        server_names = list(SERVER_MAP.keys())
        return JsonResponse({'servers': server_names})

    @define_api
    def reload_server_configs(self, config_path: Path) -> WebResponse:
        """
        ### Reload server configs

        Iterates on configured server configuration directory and loads all configured
        servers.

        **Async:** No

        **Args:**
        - `config_path` (`Path`): The path to the server configuration directory.

        **Returns:**
        - `WebResponse`: An OK response indicating successful reload.

        **Example:**
        ```python
        response = arma_api.reload_server_configs(Path('/config/servers'))
        # Ok()
        ```
        """
        logger.info('Retrieving all configured servers')
        load_server_config_directory(config_path)
        return Ok()

    @define_async_api
    async def server_ping(self, address: str, steam_port: int) -> WebResponse:
        """
        ### Ping an Arma server to check connectivity

        *Docstring generated by AI.*

        Sends a ping request to an Arma server at the specified address and port to test
        connectivity and measure response time. Uses a3sb tool with a single ping and
        1-second timeout.

        **Args:**
        - `address` (`str`): The IP address or hostname of the Arma server.
        - `steam_port` (`int`): The Steam query port of the Arma server.

        **Returns:**
        - `WebResponse`: An OK response containing the ping time as a string, or an error response if the server is unresponsive.

        **Example:**
        ```python
        response = await arma_api.server_ping('a3.bourbonwarfare.com', 2304)
        # Success: Ok('15.5')
        # Error: WebResponse(status=500, reason='ArmaServerUnresponsive')
        ```
        """
        logger.info(f'Pinging Arma server at {address}:{steam_port}')
        ping = await a3sb.ping.acall(address, steam_port, ping_count=1, ping_period=0, deadline_timeout=1)
        return Ok(str(ping))

    @define_async_api
    async def server_steam_status(self, address: str, steam_port: int) -> JsonResponse:
        """
        ### Get detailed server status via Steam query

        *Docstring generated by AI.*

        Queries an Arma server using the Steam query protocol to retrieve detailed
        server information including name, mission, player count, and server state.
        Uses a3sb tool with JSON output format and 1-second timeout.

        **Args:**
        - `address` (`str`): The IP address or hostname of the Arma server.
        - `steam_port` (`int`): The Steam query port of the Arma server.

        **Returns:**
        - `JsonResponse`: A JSON response containing server status data including name, mission, state, map, players,
        and max_players.

        **Example:**
        ```python
        response = await arma_api.server_steam_status('a3.bourbonwarfare.com', 2304)
        # Success: JsonResponse({
        #     'name': 'My Server',
        #     'mission': 'Altis Life',
        #     'state': 'LOBBY',
        #     'map': 'Altis',
        #     'players': 15,
        #     'max_players': 100
        # })
        # Error: WebResponse(status=500, reason='ArmaServerUnresponsive')
        ```
        """
        logger.info(f'Checking Arma server status at {address}:{steam_port}')
        query = await a3sb.info.acall(address, steam_port, json=True, deadline_timeout=1)
        status = ServerStatus(
            name=query['name'],
            mission=query['game'],
            state=ServerState(query['keywords']['server_state']),
            map=query['map'],
            players=query['players'],
            max_players=query['max_players'],
        )
        return JsonResponse(dataclasses.asdict(status))

    async def _manage_server(self, command: Callable[..., Awaitable[ServerResult]], server: Server) -> ServerResult:
        """
        ### Execute server management operations

        *Docstring generated by AI.*

        Internal helper method that prepares mod configurations and executes server
        management commands. Separates mods from server mods and formats them as
        semicolon-separated launch parameters for the PowerShell server management script.

        **Args:**
        - `command` (`Callable[..., Awaitable[ServerResult]]`): The server management command function to execute.
        - `server` (`Server`): The server configuration object containing all necessary parameters.

        **Returns:**
        - `ServerResult`: The result object containing server status information and operation messages.

        **Example:**
        ```python
        result = await self._manage_server(server_manage.start.acall, server_config)
        # Returns: ServerResult(message='Server started', server_status='Running', hc_status='Running')
        ```
        """
        all_mods = server.modlist().mods
        mods = [mod for mod in all_mods if mod.kind == Kind.MOD]
        server_mods = [mod for mod in all_mods if mod.kind == Kind.SERVER_MOD]

        mods = ';'.join([mod.as_launch_parameter() for mod in mods]) + ';' if len(mods) > 0 else ''
        server_mods = ';'.join([mod.as_launch_parameter() for mod in server_mods]) + ';' if len(server_mods) > 0 else ''

        logger.info(
            f"""Attempting command with
    name={server.server_name()}
    path={server.arma_base_path()}
    port={server.server_port()}
    hc_count={server.headless_client_count()}
    mods={mods}
    servermods={server_mods}"""
        )
        return await command(
            name=server.server_name(),
            path=str(server.arma_base_path()),
            port=server.server_port(),
            hc_count=server.headless_client_count(),
            mods=mods,
            servermods=server_mods,
            **{'pass': server.server_password()},  # "pass" is a keyword, so we expand a keyword dict to allow it
        )

    @define_async_api
    async def start_server(self, server_name: str) -> JsonResponse:
        """
        ### Start an Arma server

        *Docstring generated by AI.*

        Starts an Arma server with the specified name using the server management PowerShell
        script. Validates that the server exists in the configuration, then initiates the
        startup process including main server and headless clients based on configuration.

        **Args:**
        - `server_name` (`str`): The name of the server to start as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing server startup status including server_status, hc_status,
        and startup_status fields.

        **Example:**
        ```python
        response = await arma_api.start_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server started',
        #     'server_status': 'Running',
        #     'hc_status': 'Running',
        #     'startup_status': 'Completed'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Starting Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.start.acall, SERVER_MAP[server_name])
        return JsonResponse(dataclasses.asdict(response))

    @define_async_api
    async def stop_server(self, server_name: str) -> JsonResponse:
        """
        ### Stop an Arma server

        *Docstring generated by AI.*

        Stops a running Arma server with the specified name using the server management
        PowerShell script. Validates that the server exists in the configuration, then
        initiates the shutdown process for both main server and headless clients.

        **Args:**
        - `server_name` (`str`): The name of the server to stop as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing server shutdown status including server_status and hc_status fields.

        **Example:**
        ```python
        response = await arma_api.stop_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server stopped',
        #     'server_status': 'Stopped',
        #     'hc_status': 'Stopped'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Stopping Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.stop.acall, SERVER_MAP[server_name])
        return JsonResponse(dataclasses.asdict(response))

    @define_async_api
    async def restart_server(self, server_name: str) -> JsonResponse:
        """
        ### Restart an Arma server

        *Docstring generated by AI.*

        Restarts an Arma server by stopping and starting it with the specified name using
        the server management PowerShell script. Validates that the server exists in the
        configuration, then performs a complete restart cycle for both main server and
        headless clients.

        **Args:**
        - `server_name` (`str`): The name of the server to restart as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing server restart status including server_status, hc_status,
        and startup_status fields.

        **Example:**
        ```python
        response = await arma_api.restart_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server restarted',
        #     'server_status': 'Running',
        #     'hc_status': 'Running',
        #     'startup_status': 'Completed'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Restarting Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.restart.acall, SERVER_MAP[server_name])
        return JsonResponse(dataclasses.asdict(response))

    @define_async_api
    async def server_pid_status(self, server_name: str) -> JsonResponse:
        """
        ### Check server process status

        *Docstring generated by AI.*

        Checks if an Arma server is currently running by querying the server process
        status using the server management PowerShell script. Returns the current
        operational state of the server and headless clients.

        **Args:**
        - `server_name` (`str`): The name of the server to check as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing process status including server_status and hc_status fields.

        **Example:**
        ```python
        response = await arma_api.server_pid_status('main_server')
        # Success: JsonResponse({
        #     'message': 'Server status checked',
        #     'server_status': 'Running',
        #     'hc_status': 'Running'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Checking Arma server status: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.status.acall, SERVER_MAP[server_name])
        return JsonResponse(dataclasses.asdict(response))

    @define_api
    def deploy_mods(self, server_name: str) -> WebResponse:
        """
        ### Deploy mods to an Arma server

        *Docstring generated by AI.*

        Creates symbolic links for all mods in the server's modlist to the server's mods
        directory. Creates the mods directory if it doesn't exist, then links each mod
        from its home directory to the server-specific location for server operation.

        **Args:**
        - `server_name` (`str`): The name of the server to deploy mods for as defined in the server configuration.

        **Returns:**
        - `WebResponse`: An OK response if deployment is successful, or an error response if the server configuration
        is not found

        **Example:**
        ```python
        response = arma_api.deploy_mods('main_server')
        # Success: Ok()
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Deploying mods to Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]
        mod_path = server.mod_install_path()

        if not os.path.exists(mod_path):
            os.makedirs(mod_path)

        logger.info(f'Removing existing mod links in {mod_path}')
        for existing_file in mod_path.iterdir():
            if existing_file.name.startswith('@'):
                try:
                    if existing_file.is_symlink():
                        logger.info(f'Removing existing mod symlink: {existing_file}')
                        os.unlink(existing_file)
                    elif existing_file.is_dir():
                        logger.info(f'Removing existing mod directory: {existing_file}')
                        shutil.rmtree(existing_file)
                    else:
                        logger.info(f'Removing existing mod file: {existing_file}')
                        existing_file.unlink()
                except OSError as e:
                    logger.warning(f'Failed to remove existing mod {existing_file}: {e}')

        logger.info(f'Creating mod links in {mod_path} for {server.server_name()}')
        for mod in server.modlist().mods:
            mod_source = mod.directory / mod.as_launch_parameter()
            try:
                os.symlink(mod_source, mod_path / mod.as_launch_parameter(), target_is_directory=True)
                logger.info(f'Linked mod {mod.name} from {mod_source} to {mod_path / mod.as_launch_parameter()}')
            except OSError as e:
                to_path = mod_path / mod.as_launch_parameter()
                logger.warning(f'Failed to link mod {mod.name} from {mod_source} to {to_path}: {e}')

        return Ok()

    @define_api
    def deploy_keys(self, server_name: str) -> WebResponse:
        """
        ### Deploy signature keys for an Arma server

        *Docstring generated by AI.*

        Copies all .bikey signature files from the server's modlist to the server's keys
        directory. Creates the keys directory if it doesn't exist, then searches through
        all mod directories for .bikey files and copies them to enable mod verification.

        **Args:**
        - `server_name` (`str`): The name of the server to deploy keys for as defined in the server configuration.

        **Returns:**
        - `WebResponse`: An OK response if deployment is successful, or an error response if the server configuration
        is not found

        **Example:**
        ```python
        response = arma_api.deploy_keys('main_server')
        # Success: Ok()
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]
        key_path = server.key_install_path()

        if not os.path.exists(key_path):
            os.makedirs(key_path)

        keys = []
        for mod in server.modlist().mods:
            path = mod.path()
            for key_file in path.rglob('*.bikey'):
                keys.append(key_file)

        for key in keys:
            destination = key_path / key.name
            try:
                shutil.copy(key, destination)
            except shutil.SameFileError as e:
                logger.warning(f'Failed to copy key {key} to {destination}: {e}')

        return Ok()

    @define_async_api
    async def update_server(self, server_name: str) -> JsonResponse:
        """
        ### Update an Arma server

        *Docstring generated by AI.*

        Updates an Arma server by stopping it, downloading the latest server files via SteamCMD,
        redeploying mods, and starting the server again. Uses Steam credentials from global
        configuration to authenticate with the Creator DLC beta branch.

        **Args:**
        - `server_name` (`str`): The name of the server to update as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing the final server status after the update process.

        **Example:**
        ```python
        response = await arma_api.update_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server updated',
        #     'server_status': 'Running',
        #     'hc_status': 'Running'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Updating Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]

        (await self.stop_server(server_name)).raise_if_unsuccessful()

        # update server via SteamCMD
        logger.info(f'Updating Arma server {server_name} via SteamCMD')
        await Chain(
            steam.login(
                GLOBAL_CONFIGURATION.require('steam_username').get(),
                GLOBAL_CONFIGURATION.require('steam_password').get(),
            ),
            steam.force_install_dir(server.server_path()),
            steam.app_update(233780, beta='creatordlc', validate=True),
            steam.quit(),
        ).acall()

        (self.deploy_mods(server_name)).raise_if_unsuccessful()
        (self.deploy_keys(server_name)).raise_if_unsuccessful()
        (await self.start_server(server_name)).raise_if_unsuccessful()

        return await self.server_pid_status(server_name)

    @define_async_api
    async def get_out_of_date_workshop_mods(self, state: State, mods: Collection[Mod]) -> JsonResponse:
        """
        ### Identify workshop mods that need updates

        *Docstring generated by AI.*

        Compares local mod timestamps with Steam Workshop last update times to identify
        mods that have newer versions available. Fetches mod details from Steam Workshop
        API and checks if each mod's local timestamp is older than the workshop version.
        Only checks mods that are not manually installed.

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `mods` (`Collection[Mod]`): A collection of mod objects to check for updates.

        **Returns:**
        - `JsonResponse`: A JSON response containing a list of mods that need updates in the 'mods_to_update' field,
        with each mod serialized as a dictionary.

        **Example:**
        ```python
        response = await arma_api.get_out_of_date_workshop_mods(state, [mod1, mod2, mod3])
        # Success: JsonResponse({
        #     'mods_to_update': [
        #         {
        #             'name': 'ACE3',
        #             'workshop_id': '463939057',
        #             'filename': 'ace',
        #             'last_updated': '2023-01-15T10:30:00'
        #         }
        #     ]
        # })
        # Error: JsonResponse({'mods_to_update': []})
        ```
        """
        mods_to_update = []
        steam_details = await fetch_mod_details_from_workshop([mod for mod in mods if not mod.manual_install])
        steam_mods = list(steam_details.values())
        mods_to_update = [
            steam_details[WorkshopId(mod.workshop_id)] for mod in ModStore().get_out_of_date_mods(state, steam_mods)
        ]
        return JsonResponse({'mods_to_update': [dataclasses.asdict(mod) for mod in mods_to_update]})

    @define_async_api
    async def update_mods(self, state: State, mod_list: Iterable[Mod]) -> JsonResponse:
        """
        ### Update multiple mods and affected servers

        *Docstring generated by AI.*

        Updates multiple mods by identifying out-of-date versions, stopping all affected servers,
        downloading updated mods via SteamCMD, then redeploying and restarting all servers.
        Groups mods by installation directory to optimize SteamCMD operations. Only processes
        non-manual mods and handles server dependencies automatically.

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `mod_list` (`Iterable[Mod]`): An iterable collection of mod objects to check and update.

        **Returns:**
        - `JsonResponse`: A JSON response containing status information for all affected servers after the update process
        in the 'server_status' field.

        **Example:**
        ```python
        response = await arma_api.update_mods(state, [mod1, mod2, mod3])
        # Success: JsonResponse({
        #     'server_status': [
        #         {
        #             'message': 'Server updated',
        #             'server_status': 'Running',
        #             'hc_status': 'Running'
        #         }
        #     ]
        # })
        # Error: WebResponse(status=500, reason='Server operation failed')
        ```
        """
        mod_workshop_id_map: dict[WorkshopId, Mod] = {
            mod.workshop_id: mod for mod in mod_list if not mod.manual_install and mod.workshop_id is not None
        }

        out_of_date_steam_mods = [
            SteamWorkshopDetails(**detail)
            for detail in (await self.get_out_of_date_workshop_mods(state, mod_list).raise_if_unsuccessful()).contained_json.get(
                'mods_to_update', []
            )
        ]

        mods_to_update = [mod_workshop_id_map[workshop_detail.workshop_id] for workshop_detail in out_of_date_steam_mods]

        affected_servers = [s for s in SERVER_MAP.values() if s.modlist().has_mods_from(mods_to_update)]
        try:
            stopped_servers = []
            for server in affected_servers:
                (await self.stop_server(server.server_name())).raise_if_unsuccessful()
                stopped_servers.append(server)
        except BwServerError as e:
            logger.error(f'Failed to stop servers before updating mods: {e}')
            for server in stopped_servers:
                (await self.start_server(server.server_name())).raise_if_unsuccessful()
            raise e
        finally:
            del stopped_servers

        mod_install_directories: dict[Path, list[Mod]] = {}
        for mod in mods_to_update:
            if mod.manual_install:
                continue
            install_path = mod.path()
            if install_path not in mod_install_directories:
                mod_install_directories[install_path] = []
            mod_install_directories[install_path].append(mod)

        # update mods via SteamCMD
        logger.info(f'Updating Arma mods for {", ".join([server.server_name() for server in affected_servers])} via SteamCMD')
        await Chain(
            steam.login(
                GLOBAL_CONFIGURATION.require('steam_username').get(),
                GLOBAL_CONFIGURATION.require('steam_password').get(),
            ),
            # Some mods may have different install paths, so we need to handle them separately
            *[
                (
                    steam.force_install_dir(install_path),
                    *[
                        steam.workshop_download_item(107410, int(mod.workshop_id), validate=True)
                        for mod in mods
                        if mod.workshop_id is not None
                    ],
                )
                for install_path, mods in mod_install_directories.items()
            ],  # ty: ignore[invalid-argument-type]
            steam.quit(),
        ).acall()

        for server in affected_servers:
            (self.deploy_mods(server.server_name())).raise_if_unsuccessful()
            (self.deploy_keys(server.server_name())).raise_if_unsuccessful()
            (await self.start_server(server.server_name())).raise_if_unsuccessful()

        response = [(server.server_name(), await self.server_pid_status(server.server_name())) for server in affected_servers]
        return JsonResponse({n: dataclasses.asdict(r) for n, r in response})

    @define_async_api
    async def update_server_mods(self, state: State, server_name: str) -> JsonResponse:
        """
        ### Update mods for a specific Arma server

        *Docstring generated by AI.*

        Updates all mods for the specified server by delegating to the update_mods method
        with the server's modlist. Identifies the server configuration, validates it exists,
        and then updates all mods used by that server including stopping affected servers,
        downloading updates via SteamCMD, and restarting servers.

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `server_name` (`str`): The name of the server whose mods should be updated as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing status information for all affected servers after the update process
        in the 'server_status' field.

        **Example:**
        ```python
        response = await arma_api.update_server_mods(state, 'main_server')
        # Success: JsonResponse({
        #     'server_status': [
        #         {
        #             'message': 'Server updated',
        #             'server_status': 'Running',
        #             'hc_status': 'Running'
        #         }
        #     ]
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """

        logger.info(f'Updating Arma mods for: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]

        return self.update_mods(state, server.modlist().mods)

    @define_api
    def get_all_configured_mods(self) -> JsonResponse:
        """
        ### Retrieve all configured mods

        *Docstring generated by AI.*

        Returns all mods currently loaded in the mod configuration. This includes both
        workshop mods and manually installed mods. Each mod is serialized with its
        complete configuration including name, workshop ID, kind, install paths, and
        other metadata.

        **Async:** No

        **Args:**
        None

        **Returns:**
        - `JsonResponse`: A JSON response containing a list of all configured mods with their complete details.

        **Example:**
        ```python
        response = arma_api.get_all_configured_mods()
        # JsonResponse({
        #     'mods': [
        #         {
        #             'name': 'ACE3',
        #             'workshop_id': 463939057,
        #             'kind': 'mod',
        #             'manual_install': False,
        #             'directory': '@ace',
        #         },
        #         ...
        #     ]
        # })
        ```
        """
        logger.info('Retrieving all configured mods')
        mods = [dataclasses.asdict(mod) for mod in MODS.values()]
        for mod in mods:
            for key, value in mod.items():
                if isinstance(value, Path) or isinstance(value, Kind):
                    mod[key] = str(value)
        return JsonResponse({'mods': mods})

    @define_api
    def get_server_mods(self, server_name: str) -> JsonResponse:
        """
        ### Retrieve mods configured for a specific server

        *Docstring generated by AI.*

        Returns all mods that are part of the specified server's modlist. Validates that
        the server exists in the configuration, then retrieves the server's modlist and
        serializes all mods with their complete configuration.

        **Async:** No

        **Args:**
        - `server_name` (`str`): The name of the server as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing a list of mods configured for the server.

        **Example:**
        ```python
        response = arma_api.get_server_mods('main_server')
        # Success: JsonResponse({
        #     'mods': [
        #         {
        #             'name': 'ACE3',
        #             'workshop_id': 463939057,
        #             'kind': 'mod',
        #             'manual_install': False
        #         },
        #         ...
        #     ]
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Retrieving mods for server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)

        server = SERVER_MAP[server_name]
        mods = [dataclasses.asdict(mod) for mod in server.modlist().mods]
        for mod in mods:
            for key, value in mod.items():
                if isinstance(value, Path) or isinstance(value, Kind):
                    mod[key] = str(value)
        return JsonResponse({'mods': mods})

    @define_api
    def get_all_configured_modlists(self) -> JsonResponse:
        """
        ### Retrieve all configured modlists

        *Docstring generated by AI.*

        Returns all modlists currently loaded in the configuration. Each modlist includes
        its name and the list of mod names that belong to it. This provides an overview
        of all available modlist configurations that can be assigned to servers.

        **Async:** No

        **Args:**
        None

        **Returns:**
        - `JsonResponse`: A JSON response containing a dictionary mapping modlist names to their mod name lists.

        **Example:**
        ```python
        response = arma_api.get_all_configured_modlists()
        # JsonResponse({
        #     'modlists': {
        #         'main': ['ACE3', 'CBA_A3', 'TFAR'],
        #         'training': ['ACE3', 'CBA_A3'],
        #         'vanilla': []
        #     }
        # })
        ```
        """
        logger.info('Retrieving all configured modlists')
        modlists = {name: [mod.name for mod in modlist.mods] for name, modlist in MODLISTS.items()}
        return JsonResponse({'modlists': modlists})

    @define_api
    def get_server_modlist(self, server_name: str) -> JsonResponse:
        """
        ### Retrieve modlist for a specific server

        *Docstring generated by AI.*

        Returns the modlist name and mod names for the specified server. Validates that
        the server exists in the configuration, then retrieves the server's modlist
        configuration and the names of all mods in that list.

        **Async:** No

        **Args:**
        - `server_name` (`str`): The name of the server as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing the modlist name and list of mod names for the server.

        **Example:**
        ```python
        response = arma_api.get_server_modlist('main_server')
        # Success: JsonResponse({
        #     'modlist_name': 'main',
        #     'mods': ['ACE3', 'CBA_A3', 'TFAR']
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Retrieving modlist for server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)

        server = SERVER_MAP[server_name]
        modlist_name = server._config.require('modlist').get()
        mod_names = [mod.name for mod in server.modlist().mods]
        return JsonResponse({'modlist_name': modlist_name, 'mods': mod_names})

    @define_api
    def reload_mod_configuration(self, config_path: Path) -> WebResponse:
        """
        ### Reload mod configuration from disk

        *Docstring generated by AI.*

        Reloads the mod configuration by calling the load_mods function with the specified
        configuration path. This refreshes the MODS global dictionary with any changes
        made to the mod configuration files. Useful for applying configuration updates
        without restarting the application.

        **Async:** No

        **Args:**
        - `config_path` (`Path`): The path to the mod configuration directory.

        **Returns:**
        - `WebResponse`: An OK response indicating successful reload.

        **Example:**
        ```python
        response = arma_api.reload_mod_configuration(Path('/config/mods'))
        # Ok()
        ```
        """
        logger.info(f'Reloading mod configuration from: {config_path}')
        load_mods(config_path)
        return Ok()

    @define_api
    def reload_modlist_configuration(self, config_path: Path) -> WebResponse:
        """
        ### Reload modlist configuration from disk

        *Docstring generated by AI.*

        Reloads the modlist configuration by calling the load_modlists function with the
        specified configuration path. This refreshes the MODLISTS global dictionary with
        any changes made to the modlist configuration files. Useful for applying
        configuration updates without restarting the application.

        **Async:** No

        **Args:**
        - `config_path` (`Path`): The path to the modlist configuration directory.

        **Returns:**
        - `WebResponse`: An OK response indicating successful reload.

        **Example:**
        ```python
        response = arma_api.reload_modlist_configuration(Path('/config/modlists'))
        # Ok()
        ```
        """
        logger.info(f'Reloading modlist configuration from: {config_path}')
        load_modlists(config_path)
        return Ok()

    @define_api
    def flush_mods_to_disk(self, config_path: Path) -> WebResponse:
        """
        ### Flush mod configuration to disk

        *Docstring generated by AI.*

        Persists the current in-memory MODS dictionary to disk by writing configuration
        files. This saves any changes made via add_mod() or other runtime modifications
        to permanent storage. The configuration is written in TOML format to the
        specified directory.

        **Async:** No

        **Args:**
        - `config_path` (`Path`): The path to the mod configuration directory where files should be written.

        **Returns:**
        - `WebResponse`: An OK response indicating successful write to disk.

        **Example:**
        ```python
        response = arma_api.flush_mods_to_disk(Path('/config/mods'))
        # Ok()
        ```
        """
        logger.info(f'Flushing mod configuration to disk: {config_path}')
        from bw.server_ops.arma.mod import save_mods

        save_mods(config_path)
        return Ok()

    @define_api
    def flush_modlists_to_disk(self, config_path: Path) -> WebResponse:
        """
        ### Flush modlist configuration to disk

        *Docstring generated by AI.*

        Persists the current in-memory MODLISTS dictionary to disk by writing configuration
        files. This saves any changes made via add_modlist() or other runtime modifications
        to permanent storage. The configuration is written in TOML format to the
        specified directory.

        **Async:** No

        **Args:**
        - `config_path` (`Path`): The path to the modlist configuration directory where files should be written.

        **Returns:**
        - `WebResponse`: An OK response indicating successful write to disk.

        **Example:**
        ```python
        response = arma_api.flush_modlists_to_disk(Path('/config/modlists'))
        # Ok()
        ```
        """
        logger.info(f'Flushing modlist configuration to disk: {config_path}')
        from bw.server_ops.arma.mod import save_modlists

        save_modlists(config_path)
        return Ok()

    @define_api
    def add_mod(
        self,
        mod_name: str,
        workshop_id: int | None,
        kind: str | None,
        manual_install: bool | None,
        directory: str | None,
    ) -> Created:
        """
        ### Add a new mod to the configuration

        *Docstring generated by AI.*

        Adds a new mod to the MODS global dictionary with the specified configuration.
        Validates that the mod name is unique, validates the kind parameter, and ensures
        required fields are present based on the mod type (manual vs workshop). Does not
        persist to disk - configuration files must be manually updated.

        **Async:** No

        **Args:**
        - `mod_name` (`str`): The unique name for the mod.
        - `workshop_id` (`int | None`): The Steam Workshop ID for the mod, required if not manual install.
        - `kind` (`str | None`): The mod kind ('mod' or 'server_mod'), defaults to 'mod'.
        - `manual_install` (`bool | None`): Whether the mod is manually installed, defaults to False.
        - `directory` (`str | None`): The directory name for the mod

        **Raises:**
        - `ModAlreadyDefined`: If a mod with the same name already exists in the configuration.
        - `ModMissingField`: If required fields are missing based on mod type.
        - `ModInvalidKind`: If the kind parameter is not 'mod' or 'server_mod'.
        - `DuplicateModWorkshopID`: If a mod with the same workshop ID already exists.

        **Returns:**
        - `Created`: A Created response indicating the mod was successfully added.

        **Example:**
        ```python
        response = arma_api.add_mod(
            mod_name='NewMod',
            workshop_id=123456789,
            kind='mod',
            manual_install=False,
            directory=None
        )
        # Created()
        ```
        """
        logger.info(f'Adding new mod: {mod_name}')

        if mod_name in MODS:
            raise ModAlreadyDefined(mod_name, status=409)

        # Validate kind
        valid_kinds = ['mod', 'server_mod']
        if kind is not None and kind not in valid_kinds:
            raise ModInvalidKind(mod_name, kind, valid_kinds, status=400)

        # Set defaults
        kind = kind or 'mod'
        manual_install = manual_install or False

        # Validate required fields
        if not manual_install and workshop_id is None:
            raise ModMissingField(mod_name, 'workshop_id', status=400)

        if directory is None:
            raise ModMissingField(mod_name, 'directory', status=400)

        # Check for duplicate workshop ID
        if workshop_id is not None:
            for existing_name, existing_mod in MODS.items():
                if existing_mod.workshop_id == workshop_id:
                    raise DuplicateModWorkshopID(str(workshop_id), mod_name, existing_name, status=400)

        # Create the mod object
        mod = Mod(
            name=mod_name,
            workshop_id=WorkshopId(workshop_id) if workshop_id is not None else None,
            kind=Kind(kind),
            manual_install=manual_install,
            directory=Path(directory),
        )

        MODS[mod_name] = mod
        logger.info(f'Successfully added mod: {mod_name}')
        return Created()

    @define_api
    def add_modlist(self, name: str, mod_names: list[str]) -> Created:
        """
        ### Add a new modlist to the configuration

        *Docstring generated by AI.*

        Adds a new modlist to the MODLISTS global dictionary with the specified name and
        list of mod names. Validates that all referenced mods exist in the MODS dictionary
        and that the modlist name is unique. Does not persist to disk - configuration
        files must be manually updated.

        **Async:** No

        **Args:**
        - `name` (`str`): The unique name for the modlist.
        - `mod_names` (`list[str]`): A list of mod names that should be included in this modlist.

        **Raises:**
        - `ModAlreadyDefined`: If a modlist with the same name already exists in the configuration.
        - `ModNotDefined`: If any of the referenced mod names do not exist in the MODS dictionary.

        **Returns:**
        - `Created`: A Created response indicating the modlist was successfully added.

        **Example:**
        ```python
        response = arma_api.add_modlist(
            name='new_modlist',
            mod_names=['ACE3', 'CBA_A3', 'TFAR']
        )
        # Created()
        ```
        """
        logger.info(f'Adding new modlist: {name}')

        if name in MODLISTS:
            raise ModAlreadyDefined(name, status=409)

        # Validate all mod names exist
        mods = []
        for mod_name in mod_names:
            if mod_name not in MODS:
                raise ModNotDefined(mod_name, status=404)
            mods.append(MODS[mod_name])

        # Create the modlist
        modlist = Modlist(name=name, mods=mods)
        MODLISTS[name] = modlist
        logger.info(f'Successfully added modlist: {name}')
        return Created()

import os
import logging
import shutil
import dataclasses
from pathlib import Path
from collections.abc import Collection
from collections.abc import Callable, Awaitable
from collections.abc import Iterable
from bw.server_ops.arma.server import Server, SERVER_MAP
from bw.server_ops.arma.server_status import ServerStatus, ServerState
from bw.server_ops.arma.mod import Kind, Mod, fetch_mod_details_from_workshop, WorkshopId, SteamWorkshopDetails
from bw.server_ops.arma.mod_store import ModStore
from bw.subprocess.a3sb import a3sb
from bw.subprocess.server_manage import server_manage, ServerResult
from bw.subprocess.steam import steam
from bw.subprocess.command import Chain
from bw.error import BwServerError, ServerConfigNotFound
from bw.settings import GLOBAL_CONFIGURATION
from bw.response import WebResponse, Ok, JsonResponse
from bw.web_utils import define_async_api, define_api
from bw.state import State


logger = logging.getLogger('bw.server_ops.arma')


class ArmaApi:
    @define_async_api
    async def server_ping(self, address: str, steam_port: int) -> WebResponse:
        """
        ### Ping an Arma server to check connectivity

        *Docstring generated by AI.*

        Sends a ping request to an Arma server at the specified address and port to test
        connectivity and measure response time. Uses a3sb tool with a single ping and
        1-second timeout.

        **Args:**
        - `address` (`str`): The IP address or hostname of the Arma server.
        - `steam_port` (`int`): The Steam query port of the Arma server.

        **Returns:**
        - `WebResponse`: An OK response containing the ping time as a string, or an error response if the server is unresponsive.

        **Example:**
        ```python
        response = await arma_api.server_ping('a3.bourbonwarfare.com', 2304)
        # Success: Ok('15.5')
        # Error: WebResponse(status=500, reason='ArmaServerUnresponsive')
        ```
        """
        logger.info(f'Pinging Arma server at {address}:{steam_port}')
        ping = await a3sb.ping.acall(address, steam_port, ping_count=1, ping_period=0, deadline_timeout=1)
        return Ok(str(ping))

    @define_async_api
    async def server_steam_status(self, address: str, steam_port: int) -> JsonResponse:
        """
        ### Get detailed server status via Steam query

        *Docstring generated by AI.*

        Queries an Arma server using the Steam query protocol to retrieve detailed
        server information including name, mission, player count, and server state.
        Uses a3sb tool with JSON output format and 1-second timeout.

        **Args:**
        - `address` (`str`): The IP address or hostname of the Arma server.
        - `steam_port` (`int`): The Steam query port of the Arma server.

        **Returns:**
        - `JsonResponse`: A JSON response containing server status data including name, mission, state, map, players,
        and max_players.

        **Example:**
        ```python
        response = await arma_api.server_steam_status('a3.bourbonwarfare.com', 2304)
        # Success: JsonResponse({
        #     'name': 'My Server',
        #     'mission': 'Altis Life',
        #     'state': 'LOBBY',
        #     'map': 'Altis',
        #     'players': 15,
        #     'max_players': 100
        # })
        # Error: WebResponse(status=500, reason='ArmaServerUnresponsive')
        ```
        """
        logger.info(f'Checking Arma server status at {address}:{steam_port}')
        query = await a3sb.info.acall(address, steam_port, json=True, deadline_timeout=1)
        status = ServerStatus(
            name=query['name'],
            mission=query['game'],
            state=ServerState(query['keywords']['server_state']),
            map=query['map'],
            players=query['players'],
            max_players=query['max_players'],
        )
        return JsonResponse(dataclasses.asdict(status))

    async def _manage_server(self, command: Callable[..., Awaitable[ServerResult]], server: Server) -> ServerResult:
        """
        ### Execute server management operations

        *Docstring generated by AI.*

        Internal helper method that prepares mod configurations and executes server
        management commands. Separates mods from server mods and formats them as
        semicolon-separated launch parameters for the PowerShell server management script.

        **Args:**
        - `command` (`Callable[..., Awaitable[ServerResult]]`): The server management command function to execute.
        - `server` (`Server`): The server configuration object containing all necessary parameters.

        **Returns:**
        - `ServerResult`: The result object containing server status information and operation messages.

        **Example:**
        ```python
        result = await self._manage_server(server_manage.start.acall, server_config)
        # Returns: ServerResult(message='Server started', server_status='Running', hc_status='Running')
        ```
        """
        all_mods = server.modlist().mods
        mods = [mod for mod in all_mods if mod.kind == Kind.MOD]
        server_mods = [mod for mod in all_mods if mod.kind == Kind.SERVER_MOD]

        mods = ';'.join([mod.as_launch_parameter() for mod in mods]) + ';' if len(mods) > 0 else ''
        server_mods = ';'.join([mod.as_launch_parameter() for mod in server_mods]) + ';' if len(server_mods) > 0 else ''

        return await command(
            name=server.server_name(),
            path=server.arma_base_path(),
            port=server.server_port(),
            hc_count=server.headless_client_count(),
            mods=mods,
            servermods=server_mods,
            **{'pass': server.server_password()},  # "pass" is a keyword, so we expand a keyword dict to allow it
        )

    @define_async_api
    async def start_server(self, server_name: str) -> JsonResponse:
        """
        ### Start an Arma server

        *Docstring generated by AI.*

        Starts an Arma server with the specified name using the server management PowerShell
        script. Validates that the server exists in the configuration, then initiates the
        startup process including main server and headless clients based on configuration.

        **Args:**
        - `server_name` (`str`): The name of the server to start as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing server startup status including server_status, hc_status,
        and startup_status fields.

        **Example:**
        ```python
        response = await arma_api.start_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server started',
        #     'server_status': 'Running',
        #     'hc_status': 'Running',
        #     'startup_status': 'Completed'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Starting Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.start.acall, SERVER_MAP[server_name])
        return JsonResponse(dataclasses.asdict(response))

    @define_async_api
    async def stop_server(self, server_name: str) -> JsonResponse:
        """
        ### Stop an Arma server

        *Docstring generated by AI.*

        Stops a running Arma server with the specified name using the server management
        PowerShell script. Validates that the server exists in the configuration, then
        initiates the shutdown process for both main server and headless clients.

        **Args:**
        - `server_name` (`str`): The name of the server to stop as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing server shutdown status including server_status and hc_status fields.

        **Example:**
        ```python
        response = await arma_api.stop_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server stopped',
        #     'server_status': 'Stopped',
        #     'hc_status': 'Stopped'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Stopping Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.stop.acall, SERVER_MAP[server_name])
        return JsonResponse(dataclasses.asdict(response))

    @define_async_api
    async def restart_server(self, server_name: str) -> JsonResponse:
        """
        ### Restart an Arma server

        *Docstring generated by AI.*

        Restarts an Arma server by stopping and starting it with the specified name using
        the server management PowerShell script. Validates that the server exists in the
        configuration, then performs a complete restart cycle for both main server and
        headless clients.

        **Args:**
        - `server_name` (`str`): The name of the server to restart as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing server restart status including server_status, hc_status,
        and startup_status fields.

        **Example:**
        ```python
        response = await arma_api.restart_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server restarted',
        #     'server_status': 'Running',
        #     'hc_status': 'Running',
        #     'startup_status': 'Completed'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Restarting Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.restart.acall, SERVER_MAP[server_name])
        return JsonResponse(dataclasses.asdict(response))

    @define_async_api
    async def server_pid_status(self, server_name: str) -> JsonResponse:
        """
        ### Check server process status

        *Docstring generated by AI.*

        Checks if an Arma server is currently running by querying the server process
        status using the server management PowerShell script. Returns the current
        operational state of the server and headless clients.

        **Args:**
        - `server_name` (`str`): The name of the server to check as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing process status including server_status and hc_status fields.

        **Example:**
        ```python
        response = await arma_api.server_pid_status('main_server')
        # Success: JsonResponse({
        #     'message': 'Server status checked',
        #     'server_status': 'Running',
        #     'hc_status': 'Running'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Checking Arma server status: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.status.acall, SERVER_MAP[server_name])
        return JsonResponse(dataclasses.asdict(response))

    @define_api
    def deploy_mods(self, server_name: str) -> WebResponse:
        """
        ### Deploy mods to an Arma server

        *Docstring generated by AI.*

        Creates symbolic links for all mods in the server's modlist to the server's mods
        directory. Creates the mods directory if it doesn't exist, then links each mod
        from its home directory to the server-specific location for server operation.

        **Args:**
        - `server_name` (`str`): The name of the server to deploy mods for as defined in the server configuration.

        **Returns:**
        - `WebResponse`: An OK response if deployment is successful, or an error response if the server configuration
        is not found

        **Example:**
        ```python
        response = arma_api.deploy_mods('main_server')
        # Success: Ok()
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Deploying mods to Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]
        mod_path = server.mod_install_path()

        if not os.path.exists(mod_path):
            os.makedirs(mod_path)

        logger.info(f'Removing existing mod links in {mod_path}')
        for existing_file in mod_path.iterdir():
            if existing_file.name.startswith('@'):
                try:
                    if existing_file.is_symlink():
                        logger.info(f'Removing existing mod symlink: {existing_file}')
                        os.unlink(existing_file)
                    elif existing_file.is_dir():
                        logger.info(f'Removing existing mod directory: {existing_file}')
                        shutil.rmtree(existing_file)
                    else:
                        logger.info(f'Removing existing mod file: {existing_file}')
                        existing_file.unlink()
                except OSError as e:
                    logger.warning(f'Failed to remove existing mod {existing_file}: {e}')

        logger.info(f'Creating mod links in {mod_path} for {server.server_name()}')
        for mod in server.modlist().mods:
            mod_source = mod.directory / mod.as_launch_parameter()
            try:
                os.symlink(mod_source, mod_path / mod.as_launch_parameter(), target_is_directory=True)
                logger.info(f'Linked mod {mod.name} from {mod_source} to {mod_path / mod.as_launch_parameter()}')
            except OSError as e:
                to_path = mod_path / mod.as_launch_parameter()
                logger.warning(f'Failed to link mod {mod.name} from {mod_source} to {to_path}: {e}')

        return Ok()

    @define_api
    def deploy_keys(self, server_name: str) -> WebResponse:
        """
        ### Deploy signature keys for an Arma server

        *Docstring generated by AI.*

        Copies all .bikey signature files from the server's modlist to the server's keys
        directory. Creates the keys directory if it doesn't exist, then searches through
        all mod directories for .bikey files and copies them to enable mod verification.

        **Args:**
        - `server_name` (`str`): The name of the server to deploy keys for as defined in the server configuration.

        **Returns:**
        - `WebResponse`: An OK response if deployment is successful, or an error response if the server configuration
        is not found

        **Example:**
        ```python
        response = arma_api.deploy_keys('main_server')
        # Success: Ok()
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]
        key_path = server.key_install_path()

        if not os.path.exists(key_path):
            os.makedirs(key_path)

        keys = []
        for mod in server.modlist().mods:
            path = mod.path()
            for key_file in path.rglob('*.bikey'):
                keys.append(key_file)

        for key in keys:
            destination = key_path / key.name
            try:
                shutil.copy(key, destination)
            except shutil.SameFileError as e:
                logger.warning(f'Failed to copy key {key} to {destination}: {e}')

        return Ok()

    @define_async_api
    async def update_server(self, server_name: str) -> JsonResponse:
        """
        ### Update an Arma server

        *Docstring generated by AI.*

        Updates an Arma server by stopping it, downloading the latest server files via SteamCMD,
        redeploying mods, and starting the server again. Uses Steam credentials from global
        configuration to authenticate with the Creator DLC beta branch.

        **Args:**
        - `server_name` (`str`): The name of the server to update as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing the final server status after the update process.

        **Example:**
        ```python
        response = await arma_api.update_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server updated',
        #     'server_status': 'Running',
        #     'hc_status': 'Running'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Updating Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]

        (await self.stop_server(server_name)).raise_if_unsuccessful()

        # update server via SteamCMD
        logger.info(f'Updating Arma server {server_name} via SteamCMD')
        await Chain(
            steam.login(
                GLOBAL_CONFIGURATION.require('steam_username').get(),
                GLOBAL_CONFIGURATION.require('steam_password').get(),
            ),
            steam.force_install_dir(server.server_path()),
            steam.app_update(233780, beta='creatordlc', validate=True),
            steam.quit(),
        ).acall()

        (self.deploy_mods(server_name)).raise_if_unsuccessful()
        (self.deploy_keys(server_name)).raise_if_unsuccessful()
        (await self.start_server(server_name)).raise_if_unsuccessful()

        return await self.server_pid_status(server_name)

    @define_async_api
    async def get_out_of_date_workshop_mods(self, state: State, mods: Collection[Mod]) -> JsonResponse:
        """
        ### Identify workshop mods that need updates

        *Docstring generated by AI.*

        Compares local mod timestamps with Steam Workshop last update times to identify
        mods that have newer versions available. Fetches mod details from Steam Workshop
        API and checks if each mod's local timestamp is older than the workshop version.
        Only checks mods that are not manually installed.

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `mods` (`Collection[Mod]`): A collection of mod objects to check for updates.

        **Returns:**
        - `JsonResponse`: A JSON response containing a list of mods that need updates in the 'mods_to_update' field,
        with each mod serialized as a dictionary.

        **Example:**
        ```python
        response = await arma_api.get_out_of_date_workshop_mods(state, [mod1, mod2, mod3])
        # Success: JsonResponse({
        #     'mods_to_update': [
        #         {
        #             'name': 'ACE3',
        #             'workshop_id': '463939057',
        #             'filename': 'ace',
        #             'last_updated': '2023-01-15T10:30:00'
        #         }
        #     ]
        # })
        # Error: JsonResponse({'mods_to_update': []})
        ```
        """
        mods_to_update = []
        steam_details = await fetch_mod_details_from_workshop([mod for mod in mods if not mod.manual_install])
        steam_mods = list(steam_details.values())
        mods_to_update = [
            steam_details[WorkshopId(mod.workshop_id)] for mod in ModStore().get_out_of_date_mods(state, steam_mods)
        ]
        return JsonResponse({'mods_to_update': [dataclasses.asdict(mod) for mod in mods_to_update]})

    @define_async_api
    async def update_mods(self, state: State, mod_list: Iterable[Mod]) -> JsonResponse:
        """
        ### Update multiple mods and affected servers

        *Docstring generated by AI.*

        Updates multiple mods by identifying out-of-date versions, stopping all affected servers,
        downloading updated mods via SteamCMD, then redeploying and restarting all servers.
        Groups mods by installation directory to optimize SteamCMD operations. Only processes
        non-manual mods and handles server dependencies automatically.

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `mod_list` (`Iterable[Mod]`): An iterable collection of mod objects to check and update.

        **Returns:**
        - `JsonResponse`: A JSON response containing status information for all affected servers after the update process
        in the 'server_status' field.

        **Example:**
        ```python
        response = await arma_api.update_mods(state, [mod1, mod2, mod3])
        # Success: JsonResponse({
        #     'server_status': [
        #         {
        #             'message': 'Server updated',
        #             'server_status': 'Running',
        #             'hc_status': 'Running'
        #         }
        #     ]
        # })
        # Error: WebResponse(status=500, reason='Server operation failed')
        ```
        """
        mod_workshop_id_map: dict[WorkshopId, Mod] = {mod.workshop_id: mod for mod in mod_list if not mod.manual_install}

        out_of_date_steam_mods = [
            SteamWorkshopDetails(**detail)  # ty: ignore[missing-argument]
            for detail in (await self.get_out_of_date_workshop_mods(state, mod_list).raise_if_unsuccessful()).contained_json.get(
                'mods_to_update', []
            )
        ]

        mods_to_update = [mod_workshop_id_map[workshop_detail.workshop_id] for workshop_detail in out_of_date_steam_mods]

        affected_servers = [s for s in SERVER_MAP.values() if s.modlist().has_mods_from(mods_to_update)]
        try:
            stopped_servers = []
            for server in affected_servers:
                (await self.stop_server(server.server_name())).raise_if_unsuccessful()
                stopped_servers.append(server)
        except BwServerError as e:
            logger.error(f'Failed to stop servers before updating mods: {e}')
            for server in stopped_servers:
                (await self.start_server(server.server_name())).raise_if_unsuccessful()
            raise e
        finally:
            del stopped_servers

        mod_install_directories: dict[Path, list[Mod]] = {}
        for mod in mods_to_update:
            if mod.manual_install:
                continue
            install_path = mod.path()
            if install_path not in mod_install_directories:
                mod_install_directories[install_path] = []
            mod_install_directories[install_path].append(mod)

        # update mods via SteamCMD
        logger.info(f'Updating Arma mods for {", ".join([server.server_name() for server in affected_servers])} via SteamCMD')
        await Chain(
            steam.login(
                GLOBAL_CONFIGURATION.require('steam_username').get(),
                GLOBAL_CONFIGURATION.require('steam_password').get(),
            ),
            # Some mods may have different install paths, so we need to handle them separately
            *[
                (
                    steam.force_install_dir(install_path),
                    *[steam.workshop_download_item(107410, int(mod.workshop_id), validate=True) for mod in mods],
                )
                for install_path, mods in mod_install_directories.items()
            ],
            steam.quit(),
        ).acall()

        for server in affected_servers:
            (self.deploy_mods(server.server_name())).raise_if_unsuccessful()
            (self.deploy_keys(server.server_name())).raise_if_unsuccessful()
            (await self.start_server(server.server_name())).raise_if_unsuccessful()

        response = [(server.server_name(), await self.server_pid_status(server.server_name())) for server in affected_servers]
        return JsonResponse({n: dataclasses.asdict(r) for n, r in response})

    @define_async_api
    async def update_server_mods(self, state: State, server_name: str) -> JsonResponse:
        """
        ### Update mods for a specific Arma server

        *Docstring generated by AI.*

        Updates all mods for the specified server by delegating to the update_mods method
        with the server's modlist. Identifies the server configuration, validates it exists,
        and then updates all mods used by that server including stopping affected servers,
        downloading updates via SteamCMD, and restarting servers.

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `server_name` (`str`): The name of the server whose mods should be updated as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing status information for all affected servers after the update process
        in the 'server_status' field.

        **Example:**
        ```python
        response = await arma_api.update_server_mods(state, 'main_server')
        # Success: JsonResponse({
        #     'server_status': [
        #         {
        #             'message': 'Server updated',
        #             'server_status': 'Running',
        #             'hc_status': 'Running'
        #         }
        #     ]
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """

        logger.info(f'Updating Arma mods for: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]

        return self.update_mods(state, server.modlist().mods)

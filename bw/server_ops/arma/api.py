import os
import logging
import shutil
import dataclasses
from collections.abc import Callable, Awaitable
from bw.server_ops.arma.server import Server, SERVER_MAP
from bw.server_ops.arma.server_status import ServerStatus, ServerState
from bw.server_ops.arma.mod import Kind
from bw.subprocess.a3sb import a3sb
from bw.subprocess.server_manage import server_manage, ServerResult
from bw.subprocess.steam import steam
from bw.subprocess.command import Chain
from bw.error import ServerConfigNotFound
from bw.settings import GLOBAL_CONFIGURATION
from bw.response import WebResponse, Ok, JsonResponse
from bw.web_utils import define_async_api, define_api


logger = logging.getLogger('bw.server_ops.arma')


class ArmaApi:
    @define_async_api
    async def server_ping(self, address: str, steam_port: int) -> WebResponse:
        """
        ### Ping an Arma server to check connectivity

        *Docstring generated by AI.*

        Sends a ping request to an Arma server at the specified address and port to test
        connectivity and measure response time. Uses a3sb tool with a single ping and
        1-second timeout.

        **Args:**
        - `address` (`str`): The IP address or hostname of the Arma server.
        - `steam_port` (`int`): The Steam query port of the Arma server.

        **Returns:**
        - `WebResponse`: An OK response containing the ping time as a string, or an error response if the server is unresponsive.

        **Example:**
        ```python
        response = await arma_api.server_ping('a3.bourbonwarfare.com', 2304)
        # Success: Ok('15.5')
        # Error: WebResponse(status=500, reason='ArmaServerUnresponsive')
        ```
        """
        logger.info(f'Pinging Arma server at {address}:{steam_port}')
        ping = await a3sb.ping.acall(address, steam_port, ping_count=1, ping_period=0, deadline_timeout=1)
        return Ok(str(ping))

    @define_async_api
    async def server_steam_status(self, address: str, steam_port: int) -> JsonResponse:
        """
        ### Get detailed server status via Steam query

        *Docstring generated by AI.*

        Queries an Arma server using the Steam query protocol to retrieve detailed
        server information including name, mission, player count, and server state.
        Uses a3sb tool with JSON output format and 1-second timeout.

        **Args:**
        - `address` (`str`): The IP address or hostname of the Arma server.
        - `steam_port` (`int`): The Steam query port of the Arma server.

        **Returns:**
        - `JsonResponse`: A JSON response containing server status data including name, mission, state, map, players,
        and max_players.

        **Example:**
        ```python
        response = await arma_api.server_steam_status('a3.bourbonwarfare.com', 2304)
        # Success: JsonResponse({
        #     'name': 'My Server',
        #     'mission': 'Altis Life',
        #     'state': 'LOBBY',
        #     'map': 'Altis',
        #     'players': 15,
        #     'max_players': 100
        # })
        # Error: WebResponse(status=500, reason='ArmaServerUnresponsive')
        ```
        """
        logger.info(f'Checking Arma server status at {address}:{steam_port}')
        query = await a3sb.info.acall(address, steam_port, json=True, deadline_timeout=1)
        status = ServerStatus(
            name=query['name'],
            mission=query['game'],
            state=ServerState(query['keywords']['server_state']),
            map=query['map'],
            players=query['players'],
            max_players=query['max_players'],
        )
        return JsonResponse(dataclasses.asdict(status))

    async def _manage_server(command: Callable[..., Awaitable[ServerResult]], server: Server) -> ServerResult:
        """
        ### Execute server management operations

        *Docstring generated by AI.*

        Internal helper method that prepares mod configurations and executes server
        management commands. Separates mods from server mods and formats them as
        semicolon-separated launch parameters for the PowerShell server management script.

        **Args:**
        - `command` (`Callable[..., Awaitable[ServerResult]]`): The server management command function to execute.
        - `server` (`Server`): The server configuration object containing all necessary parameters.

        **Returns:**
        - `ServerResult`: The result object containing server status information and operation messages.

        **Example:**
        ```python
        result = await self._manage_server(server_manage.start.acall, server_config)
        # Returns: ServerResult(message='Server started', server_status='Running', hc_status='Running')
        ```
        """
        all_mods = server.modlist().mods
        mods = [mod for mod in all_mods if mod.kind == Kind.MOD]
        server_mods = [mod for mod in all_mods if mod.kind == Kind.SERVER_MOD]

        mods = ';'.join([mod.as_launch_parameter() for mod in mods]) + ';' if len(mods) > 0 else ''
        server_mods = ';'.join([mod.as_launch_parameter() for mod in server_mods]) + ';' if len(server_mods) > 0 else ''

        return await command(
            name=server.server_name(),
            path=server.arma_base_path(),
            port=server.server_port(),
            hc_count=server.headless_client_count(),
            mods=mods,
            servermods=server_mods,
            **{'pass': server.server_password()},  # "pass" is a keyword, so we expand a keyword dict to allow it
        )

    @define_async_api
    async def start_server(self, server_name: str) -> JsonResponse:
        """
        ### Start an Arma server

        *Docstring generated by AI.*

        Starts an Arma server with the specified name using the server management PowerShell
        script. Validates that the server exists in the configuration, then initiates the
        startup process including main server and headless clients based on configuration.

        **Args:**
        - `server_name` (`str`): The name of the server to start as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing server startup status including server_status, hc_status,
        and startup_status fields.

        **Example:**
        ```python
        response = await arma_api.start_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server started',
        #     'server_status': 'Running',
        #     'hc_status': 'Running',
        #     'startup_status': 'Completed'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Starting Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.start.acall, SERVER_MAP[server_name])
        return JsonResponse(response.asdict())

    @define_async_api
    async def stop_server(self, server_name: str) -> JsonResponse:
        """
        ### Stop an Arma server

        *Docstring generated by AI.*

        Stops a running Arma server with the specified name using the server management
        PowerShell script. Validates that the server exists in the configuration, then
        initiates the shutdown process for both main server and headless clients.

        **Args:**
        - `server_name` (`str`): The name of the server to stop as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing server shutdown status including server_status and hc_status fields.

        **Example:**
        ```python
        response = await arma_api.stop_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server stopped',
        #     'server_status': 'Stopped',
        #     'hc_status': 'Stopped'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Stopping Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.stop.acall, SERVER_MAP[server_name])
        return JsonResponse(response.asdict())

    @define_async_api
    async def restart_server(self, server_name: str) -> JsonResponse:
        """
        ### Restart an Arma server

        *Docstring generated by AI.*

        Restarts an Arma server by stopping and starting it with the specified name using
        the server management PowerShell script. Validates that the server exists in the
        configuration, then performs a complete restart cycle for both main server and
        headless clients.

        **Args:**
        - `server_name` (`str`): The name of the server to restart as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing server restart status including server_status, hc_status,
        and startup_status fields.

        **Example:**
        ```python
        response = await arma_api.restart_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server restarted',
        #     'server_status': 'Running',
        #     'hc_status': 'Running',
        #     'startup_status': 'Completed'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Restarting Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.restart.acall, SERVER_MAP[server_name])
        return JsonResponse(response.asdict())

    @define_async_api
    async def server_pid_status(self, server_name: str) -> JsonResponse:
        """
        ### Check server process status

        *Docstring generated by AI.*

        Checks if an Arma server is currently running by querying the server process
        status using the server management PowerShell script. Returns the current
        operational state of the server and headless clients.

        **Args:**
        - `server_name` (`str`): The name of the server to check as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing process status including server_status and hc_status fields.

        **Example:**
        ```python
        response = await arma_api.server_pid_status('main_server')
        # Success: JsonResponse({
        #     'message': 'Server status checked',
        #     'server_status': 'Running',
        #     'hc_status': 'Running'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Checking Arma server status: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        response = await self._manage_server(server_manage.status.acall, SERVER_MAP[server_name])
        return JsonResponse(response.asdict())

    @define_api
    def deploy_mods(self, server_name: str) -> WebResponse:
        """
        ### Deploy mods to an Arma server

        *Docstring generated by AI.*

        Creates symbolic links for all mods in the server's modlist to the server's mods
        directory. Creates the mods directory if it doesn't exist, then links each mod
        from its home directory to the server-specific location for server operation.

        **Args:**
        - `server_name` (`str`): The name of the server to deploy mods for as defined in the server configuration.

        **Returns:**
        - `WebResponse`: An OK response if deployment is successful, or an error response if the server configuration is not found

        **Example:**
        ```python
        response = await arma_api.deploy_mods('main_server')
        # Success: Ok()
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Deploying mods to Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]
        mod_path = server.mod_install_path()

        if not os.path.exists(mod_path):
            os.makedirs(mod_path)

        logger.info(f'Removing existing mod links in {mod_path}')
        for existing_file in mod_path.iterdir():
            if existing_file.name.startswith('@'):
                try:
                    if existing_file.is_symlink():
                        logger.info(f'Removing existing mod symlink: {existing_file}')
                        os.unlink(existing_file)
                    elif existing_file.is_dir():
                        logger.info(f'Removing existing mod directory: {existing_file}')
                        shutil.rmtree(existing_file)
                    else:
                        logger.info(f'Removing existing mod file: {existing_file}')
                        existing_file.unlink()
                except OSError as e:
                    logger.warning(f'Failed to remove existing mod {existing_file}: {e}')

        logger.info(f'Creating mod links in {mod_path} for {server.server_name()}')
        for mod in server.modlist().mods:
            mod_source = mod.directory / mod.as_launch_parameter()
            try:
                os.symlink(mod_source, mod_path / mod.as_launch_parameter(), target_is_directory=True)
                logger.info(f'Linked mod {mod.name} from {mod_source} to {mod_path / mod.as_launch_parameter()}')
            except OSError as e:
                to_path = mod_path / mod.as_launch_parameter()
                logger.warning(f'Failed to link mod {mod.name} from {mod_source} to {to_path}: {e}')

        return Ok()

    @define_api
    def deploy_keys(self, server_name: str) -> WebResponse:
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]
        key_path = server.key_install_path()

        if not os.path.exists(key_path):
            os.makedirs(key_path)

        keys = []
        for mod in server.modlist().mods:
            path = mod.path()
            for key_file in path.rglob('*.bikey'):
                keys.append(key_file)

        for key in keys:
            destination = key_path / key.name
            try:
                shutil.copy(key, destination)
            except shutil.SameFileError as e:
                logger.warning(f'Failed to copy key {key} to {destination}: {e}')

        return Ok()

    @define_async_api
    async def update_server(self, server_name: str) -> JsonResponse:
        """
        ### Update an Arma server

        *Docstring generated by AI.*

        Updates an Arma server by stopping it, downloading the latest server files via SteamCMD,
        redeploying mods, and starting the server again. Uses Steam credentials from global
        configuration to authenticate with the Creator DLC beta branch.

        **Args:**
        - `server_name` (`str`): The name of the server to update as defined in the server configuration.

        **Returns:**
        - `JsonResponse`: A JSON response containing the final server status after the update process.

        **Example:**
        ```python
        response = await arma_api.update_server('main_server')
        # Success: JsonResponse({
        #     'message': 'Server updated',
        #     'server_status': 'Running',
        #     'hc_status': 'Running'
        # })
        # Error: WebResponse(status=404, reason='ServerConfigNotFound')
        ```
        """
        logger.info(f'Updating Arma server: {server_name}')
        if server_name not in SERVER_MAP:
            raise ServerConfigNotFound(server_name)
        server = SERVER_MAP[server_name]

        (await self.stop_server(server_name)).raise_if_unsuccessful()

        # update server via SteamCMD
        logger.info(f'Updating Arma server {server_name} via SteamCMD')
        await Chain(
            steam.login(
                GLOBAL_CONFIGURATION.require('steam_username').get(),
                GLOBAL_CONFIGURATION.require('steam_password').get(),
            ),
            steam.force_install_dir(server.server_path()),
            steam.app_update('233780', beta='creatordlc', validate=True),
            steam.quit(),
        ).acall()

        (self.deploy_mods(server_name)).raise_if_unsuccessful()
        (self.deploy_keys(server_name)).raise_if_unsuccessful()
        (await self.start_server(server_name)).raise_if_unsuccessful()

        return self.server_pid_status(server_name)

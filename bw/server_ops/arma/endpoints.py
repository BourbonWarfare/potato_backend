import logging
import urllib.parse
from quart import Blueprint

from bw.web_utils import url_endpoint, json_endpoint
from bw.response import JsonResponse, WebResponse
from bw.auth.decorators import require_user_role, require_session
from bw.auth.roles import Roles
from bw.server_ops.arma.api import ArmaApi
from bw.models.auth import User
from bw.environment import ENVIRONMENT


logger = logging.getLogger('bw.server_ops.arma')


def define_arma(api: Blueprint, local: Blueprint, html: Blueprint):
    @api.get('servers')
    @url_endpoint
    async def get_all_servers() -> JsonResponse:
        """
        ### Get all configured servers

        *Docstring generated by AI.*

        Returns a list of all server names currently configured in the system. This provides
        an inventory of all Arma servers that the backend knows about and can manage. No
        authentication required.

        **Args:**
        None

        **Returns:**
        - `JsonResponse`:
        - **Success (200)**: JSON response containing list of all server names
        - **Error (500)**: HTTP 500 response for server errors

        **Example:**
        GET /api/v1/server_ops/arma/servers

        Success response (200):
        {
            "servers": ["Main Server", "Offnight", "Staging"]
        }
        """
        logger.info('Getting all configured servers')
        return ArmaApi().get_all_servers()

    @api.post('/<string:server>/start')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def start_server(session_user: User, server: str) -> WebResponse:
        """
        ### Start an Arma server

        *Docstring generated by AI.*

        Starts an Arma server with the specified name. Requires the `can_manage_server` role
        to execute. Initiates the startup process including main server and headless clients
        based on the server configuration.

        **Args:**
        - `server` (`str`): The name of the server to start as defined in the server configuration (path parameter).

        **Returns:**
        - `WebResponse`: HTTP response indicating server startup status
          - **Success (200)**: Server started successfully
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/main_server/start

        Success response (200):
        {
            "message": "Server started",
            "server_status": "Running",
            "hc_status": "Running",
            "startup_status": "Completed"
        }
        ```
        """
        server = urllib.parse.unquote_plus(server)
        logger.info(f'User {session_user.id} is trying to start {server}')
        return await ArmaApi().start_server(server)

    @api.post('/<string:server>/stop')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def stop_server(session_user: User, server: str) -> WebResponse:
        """
        ### Stop an Arma server

        *Docstring generated by AI.*

        Stops a running Arma server with the specified name. Requires the `can_manage_server`
        role to execute. Initiates the shutdown process for both main server and headless
        clients using the server management PowerShell script.

        **Args:**
        - `server` (`str`): The name of the server to stop as defined in the server configuration (path parameter).

        **Returns:**
        - `WebResponse`: HTTP response indicating server shutdown status
          - **Success (200)**: Server stopped successfully
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/main_server/stop

        Success response (200):
        {
            "message": "Server stopped",
            "server_status": "Stopped",
            "hc_status": "Stopped"
        }
        ```
        """
        server = urllib.parse.unquote_plus(server)
        logger.info(f'User {session_user.id} is trying to stop {server}')
        return await ArmaApi().stop_server(server)

    @api.post('/<string:server>/restart')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def restart_server(session_user: User, server: str) -> WebResponse:
        """
        ### Restart an Arma server

        *Docstring generated by AI.*

        Restarts an Arma server by stopping and starting it with the specified name. Requires
        the `can_manage_server` role to execute. Performs a complete restart cycle for both
        main server and headless clients using the server management PowerShell script.

        **Args:**
        - `server` (`str`): The name of the server to restart as defined in the server configuration (path parameter).

        **Returns:**
        - `WebResponse`: HTTP response indicating server restart status
          - **Success (200)**: Server restarted successfully
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/main_server/restart

        Success response (200):
        {
            "message": "Server restarted",
            "server_status": "Running",
            "hc_status": "Running",
            "startup_status": "Completed"
        }
        ```
        """
        server = urllib.parse.unquote_plus(server)
        logger.info(f'User {session_user.id} is trying to restart {server}')
        return await ArmaApi().restart_server(server)

    @api.post('/<string:server>/update')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def update_server(session_user: User, server: str) -> WebResponse:
        """
        ### Update an Arma server

        *Docstring generated by AI.*

        Updates an Arma server by stopping it, downloading the latest server files via SteamCMD,
        redeploying mods, and starting the server again. Requires the `can_manage_server` role
        to execute. Uses Steam credentials from global configuration to authenticate with the
        Creator DLC beta branch.

        **Args:**
        - `server` (`str`): The name of the server to update as defined in the server configuration (path parameter).

        **Returns:**
        - `WebResponse`: HTTP response indicating server update status
          - **Success (200)**: Server updated successfully
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/main_server/update

        Success response (200):
        {
            "message": "Server status checked",
            "server_status": "Running",
            "hc_status": "Running"
        }
        ```
        """
        server = urllib.parse.unquote_plus(server)
        logger.info(f'User {session_user.id} is trying to update {server}')
        return await ArmaApi().update_server(server)

    @api.post('/<string:server>/update_mods')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def update_server_mods(session_user: User, server: str) -> WebResponse:
        """
        ### Update mods for a specific Arma server

        *Docstring generated by AI.*

        Updates all mods for the specified server by identifying out-of-date versions, stopping
        all affected servers, downloading updated mods via SteamCMD, then redeploying and
        restarting all servers. Requires the `can_manage_server` role to execute. Only processes
        non-manual mods and handles server dependencies automatically.

        **Args:**
        - `server` (`str`): The name of the server whose mods should be updated as defined in the server configuration.

        **Returns:**
        - `WebResponse`: HTTP response indicating mod update status
          - **Success (200)**: Mods updated successfully for the server
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/main_server/update_mods

        Success response (200):
        {
            "server_status": [
                {
                    "message": "Server updated",
                    "server_status": "Running",
                    "hc_status": "Running"
                }
            ]
        }
        ```
        """
        server = urllib.parse.unquote_plus(server)
        logger.info(f'User {session_user.id} is trying to update the mods of {server}')
        return await ArmaApi().update_server_mods(server)

    @api.get('/<string:server>/healthcheck')
    @url_endpoint
    async def healthcheck_server(server: str) -> JsonResponse:
        """
        ### Check server health status

        *Docstring generated by AI.*

        Checks if an Arma server is currently running by querying the server process
        status using the server management PowerShell script. Returns the current
        operational state of the server and headless clients in JSON format.

        **Args:**
        - `server` (`str`): The name of the server to check as defined in the server configuration (path parameter).

        **Returns:**
        - `JsonResponse`: JSON response containing process status
          - **Success (200)**: `{'message': 'Server status checked', 'server_status': 'Running', 'hc_status': 'Running'}`
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        GET /api/v1/server_ops/arma/main_server/healthcheck

        Success response (200):
        {
            "message": "Server status checked",
            "server_status": "Running",
            "hc_status": "Running"
        }
        ```
        """
        server = urllib.parse.unquote_plus(server)
        logger.info(f'Getting the status of {server}')
        return await ArmaApi().server_pid_status(server)

    @api.get('mods')
    @url_endpoint
    async def get_configured_mods() -> JsonResponse:
        """
        ### Get all configured mods

        *Docstring generated by AI.*

        Retrieves all mods currently configured in the system. Returns complete mod
        configuration including name, workshop ID, kind, install paths, and other metadata
        for each mod. No authentication required.

        **Args:**
        None

        **Returns:**
        - `JsonResponse`:
          - **Success (200)**: JSON response containing list of all configured mods
          - **Error (500)**: HTTP 500 response for server errors

        **Example:**
        ```
        GET /api/v1/server_ops/arma/mods

        Success response (200):
        {
            "mods": [
                {
                    "name": "ACE3",
                    "workshop_id": 463939057,
                    "kind": "mod",
                    "manual_install": false,
                    "mod_directory": "@ace",
                    "server_mod_directory": null
                }
            ]
        }
        ```
        """
        logger.info('Getting all configured mods')
        return ArmaApi().get_all_configured_mods()

    @api.get('mods/<string:server>')
    @url_endpoint
    async def get_server_mods(server: str) -> JsonResponse:
        """
        ### Get mods configured for a specific server

        *Docstring generated by AI.*

        Retrieves all mods that are part of the specified server's modlist. Returns
        complete mod configuration for each mod used by the server. No authentication
        required.

        **Args:**
        - `server` (`str`): The name of the server as defined in the server configuration (path parameter).

        **Returns:**
        - `JsonResponse`:
          - **Success (200)**: JSON response containing list of mods for the specified server
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for server errors

        **Example:**
        ```
        GET /api/v1/server_ops/arma/mods/main_server

        Success response (200):
        {
            "mods": [
                {
                    "name": "ACE3",
                    "workshop_id": 463939057,
                    "kind": "mod"
                }
            ]
        }
        ```
        """
        server = urllib.parse.unquote_plus(server)
        logger.info(f'Getting mods for server: {server}')
        return ArmaApi().get_server_mods(server)

    @api.get('mods/lists')
    @url_endpoint
    async def get_configured_modlists() -> JsonResponse:
        """
        ### Get all configured modlists

        *Docstring generated by AI.*

        Retrieves all modlists currently configured in the system. Returns a dictionary
        mapping modlist names to their lists of mod names. This provides an overview of
        all available modlist configurations that can be assigned to servers. No
        authentication required.

        **Args:**
        None

        **Returns:**
        - `JsonResponse`:
          - **Success (200)**: JSON response containing all configured modlists
          - **Error (500)**: HTTP 500 response for server errors

        **Example:**
        ```
        GET /api/v1/server_ops/arma/mods/lists

        Success response (200):
        {
            "modlists": {
                "main": ["ACE3", "CBA_A3", "TFAR"],
                "training": ["ACE3", "CBA_A3"],
                "vanilla": []
            }
        }
        ```
        """
        logger.info('Getting all configured modlists')
        return ArmaApi().get_all_configured_modlists()

    @api.get('mods/list/<string:server>')
    @url_endpoint
    async def get_server_modlist(server: str) -> JsonResponse:
        """
        ### Get modlist for a specific server

        *Docstring generated by AI.*

        Retrieves the modlist name and mod names for the specified server. Returns
        the name of the modlist assigned to the server and the list of all mod names
        in that modlist. No authentication required.

        **Args:**
        - `server` (`str`): The name of the server as defined in the server configuration (path parameter).

        **Returns:**
        - `JsonResponse`:
          - **Success (200)**: JSON response containing modlist name and mod names for the server
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for server errors

        **Example:**
        ```
        GET /api/v1/server_ops/arma/mods/list/main_server

        Success response (200):
        {
            "modlist_name": "main",
            "mods": ["ACE3", "CBA_A3", "TFAR"]
        }
        ```
        """
        server = urllib.parse.unquote_plus(server)
        logger.info(f'Getting modlist for server: {server}')
        return ArmaApi().get_server_modlist(server)

    @api.post('mods/reload')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def reload_mods(session_user: User) -> WebResponse:
        """
        ### Reload mod configuration

        *Docstring generated by AI.*

        Reloads the mod configuration from disk by calling the load_mods function. This
        refreshes the MODS global dictionary with any changes made to the mod configuration
        files. Requires the `can_manage_server` role to execute. Useful for applying
        configuration updates without restarting the application.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).

        **Returns:**
        - `WebResponse`:
          - **Success (200)**: Mod configuration reloaded successfully
          - **Error (403)**: HTTP 403 response if user lacks required role
          - **Error (500)**: HTTP 500 response for server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/mods/reload

        Success response (200):
        OK
        ```
        """
        logger.info(f'User {session_user.id} is reloading mod configuration')
        mod_config_path = ENVIRONMENT.arma_mod_config_path()
        return ArmaApi().reload_mod_configuration(mod_config_path)

    @api.post('mods/lists/reload')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def reload_modlists(session_user: User) -> WebResponse:
        """
        ### Reload modlist configuration

        *Docstring generated by AI.*

        Reloads the modlist configuration from disk by calling the load_modlists function.
        This refreshes the MODLISTS global dictionary with any changes made to the modlist
        configuration files. Requires the `can_manage_server` role to execute. Useful for
        applying configuration updates without restarting the application.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).

        **Returns:**
        - `WebResponse`:
          - **Success (200)**: Modlist configuration reloaded successfully
          - **Error (403)**: HTTP 403 response if user lacks required role
          - **Error (500)**: HTTP 500 response for server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/mods/lists/reload

        Success response (200):
        OK
        ```
        """
        logger.info(f'User {session_user.id} is reloading modlist configuration')
        modlist_config_path = ENVIRONMENT.arma_modlist_config_path()
        return ArmaApi().reload_modlist_configuration(modlist_config_path)

    @api.post('mods/flush')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def flush_mods(session_user: User) -> WebResponse:
        """
        ### Flush mod configuration to disk

        *Docstring generated by AI.*

        Persists the current in-memory MODS dictionary to disk by writing configuration
        files. This saves any changes made via add_mod() or other runtime modifications
        to permanent storage. Requires the `can_manage_server` role to execute.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).

        **Returns:**
        - `WebResponse`:
          - **Success (200)**: Mod configuration flushed to disk successfully
          - **Error (403)**: HTTP 403 response if user lacks required role
          - **Error (500)**: HTTP 500 response for file write errors or other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/mods/flush

        Success response (200):
        OK
        ```
        """
        logger.info(f'User {session_user.id} is flushing mod configuration to disk')
        mod_config_path = ENVIRONMENT.arma_mod_config_path()
        return ArmaApi().flush_mods_to_disk(mod_config_path)

    @api.post('mods/lists/flush')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def flush_modlists(session_user: User) -> WebResponse:
        """
        ### Flush modlist configuration to disk

        *Docstring generated by AI.*

        Persists the current in-memory MODLISTS dictionary to disk by writing configuration
        files. This saves any changes made via add_modlist() or other runtime modifications
        to permanent storage. Requires the `can_manage_server` role to execute.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).

        **Returns:**
        - `WebResponse`:
          - **Success (200)**: Modlist configuration flushed to disk successfully
          - **Error (403)**: HTTP 403 response if user lacks required role
          - **Error (500)**: HTTP 500 response for file write errors or other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/mods/lists/flush

        Success response (200):
        OK
        ```
        """
        logger.info(f'User {session_user.id} is flushing modlist configuration to disk')
        modlist_config_path = ENVIRONMENT.arma_modlist_config_path()
        return ArmaApi().flush_modlists_to_disk(modlist_config_path)

    @api.post('mods')
    @json_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def add_new_mod(
        session_user: User,
        mod_name: str,
        workshop_id: int | None,
        kind: str | None,
        manual_install: bool | None,
        directory: str | None,
    ) -> WebResponse:
        """
        ### Add a new mod

        *Docstring generated by AI.*

        Adds a new mod to the MODS global dictionary with the specified configuration.
        Requires the `can_manage_server` role to execute. Validates that the mod name
        is unique, validates the kind parameter, and ensures required fields are present
        based on the mod type. Does not persist to disk - configuration files must be
        manually updated.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).
        - `mod_name` (`str`): The unique name for the mod.
        - `workshop_id` (`int | None`): The Steam Workshop ID for the mod, required if not manual install.
        - `kind` (`str | None`): The mod kind ('mod' or 'server_mod'), defaults to 'mod'.
        - `manual_install` (`bool | None`): Whether the mod is manually installed, defaults to False.
        - `directory` (`str | None`): The directory name for the mod.

        **Returns:**
        - `WebResponse`:
          - **Success (201)**: Mod created successfully
          - **Error (400)**: HTTP 400 response if validation fails or required fields are missing
          - **Error (403)**: HTTP 403 response if user lacks required role
          - **Error (409)**: HTTP 409 response if mod name or workshop ID already exists
          - **Error (500)**: HTTP 500 response for server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/mods
        {
            "mod_name": "NewMod",
            "workshop_id": 123456789,
            "kind": "mod",
            "manual_install": false,
            "directory": null
        }

        Success response (201):
        Created
        ```
        """
        logger.info(f'User {session_user.id} is adding new mod: {mod_name}')
        return ArmaApi().add_mod(
            mod_name=mod_name,
            workshop_id=workshop_id,
            kind=kind,
            manual_install=manual_install,
            directory=directory,
        )

    @api.post('mods/lists')
    @json_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def add_new_modlist(session_user: User, name: str, mods: list[str]) -> WebResponse:
        """
        ### Add a new modlist

        *Docstring generated by AI.*

        Adds a new modlist to the MODLISTS global dictionary with the specified name and
        list of mod names. Requires the `can_manage_server` role to execute. Validates
        that all referenced mods exist in the MODS dictionary and that the modlist name
        is unique. Does not persist to disk - configuration files must be manually updated.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).
        - `name` (`str`): The unique name for the modlist.
        - `mods` (`list[str]`): A list of mod names that should be included in this modlist.

        **Returns:**
        - `WebResponse`:
          - **Success (201)**: Modlist created successfully
          - **Error (400)**: HTTP 400 response if validation fails
          - **Error (403)**: HTTP 403 response if user lacks required role
          - **Error (404)**: HTTP 404 response if referenced mod does not exist
          - **Error (409)**: HTTP 409 response if modlist name already exists
          - **Error (500)**: HTTP 500 response for server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/mods/lists
        {
            "name": "new_modlist",
            "mods": ["ACE3", "CBA_A3", "TFAR"]
        }

        Success response (201):
        Created
        ```
        """
        logger.info(f'User {session_user.id} is adding new modlist: {name}')
        return ArmaApi().add_modlist(name=name, mod_names=mods)

import logging
from quart import Blueprint

from bw.web_utils import url_endpoint
from bw.response import JsonResponse, WebResponse
from bw.auth.decorators import require_user_role, require_session
from bw.auth.roles import Roles
from bw.server_ops.arma.api import ArmaApi
from bw.models.auth import User


logger = logging.getLogger('bw.server_ops.arma')


def define_arma(api: Blueprint, local: Blueprint, html: Blueprint):
    @api.post('/<string:server>/start')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def start_server(session_user: User, server: str) -> WebResponse:
        """
        ### Start an Arma server

        *Docstring generated by AI.*

        Starts an Arma server with the specified name. Requires the `can_manage_server` role
        to execute. Initiates the startup process including main server and headless clients
        based on the server configuration.

        **Args:**
        - `server` (`str`): The name of the server to start as defined in the server configuration (path parameter).

        **Returns:**
        - `WebResponse`: HTTP response indicating server startup status
          - **Success (200)**: Server started successfully
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/main_server/start

        Success response (200):
        {
            "message": "Server started",
            "server_status": "Running",
            "hc_status": "Running",
            "startup_status": "Completed"
        }
        ```
        """
        logger.info(f'User {session_user.id} is trying to start {server}')
        return await ArmaApi().start_server(server)

    @api.post('/<string:server>/stop')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def stop_server(session_user: User, server: str) -> WebResponse:
        """
        ### Stop an Arma server

        *Docstring generated by AI.*

        Stops a running Arma server with the specified name. Requires the `can_manage_server`
        role to execute. Initiates the shutdown process for both main server and headless
        clients using the server management PowerShell script.

        **Args:**
        - `server` (`str`): The name of the server to stop as defined in the server configuration (path parameter).

        **Returns:**
        - `WebResponse`: HTTP response indicating server shutdown status
          - **Success (200)**: Server stopped successfully
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/main_server/stop

        Success response (200):
        {
            "message": "Server stopped",
            "server_status": "Stopped",
            "hc_status": "Stopped"
        }
        ```
        """
        logger.info(f'User {session_user.id} is trying to stop {server}')
        return await ArmaApi().stop_server(server)

    @api.post('/<string:server>/restart')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def restart_server(session_user: User, server: str) -> WebResponse:
        """
        ### Restart an Arma server

        *Docstring generated by AI.*

        Restarts an Arma server by stopping and starting it with the specified name. Requires
        the `can_manage_server` role to execute. Performs a complete restart cycle for both
        main server and headless clients using the server management PowerShell script.

        **Args:**
        - `server` (`str`): The name of the server to restart as defined in the server configuration (path parameter).

        **Returns:**
        - `WebResponse`: HTTP response indicating server restart status
          - **Success (200)**: Server restarted successfully
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/main_server/restart

        Success response (200):
        {
            "message": "Server restarted",
            "server_status": "Running",
            "hc_status": "Running",
            "startup_status": "Completed"
        }
        ```
        """
        logger.info(f'User {session_user.id} is trying to restart {server}')
        return await ArmaApi().restart_server(server)

    @api.post('/<string:server>/update')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def update_server(session_user: User, server: str) -> WebResponse:
        """
        ### Update an Arma server

        *Docstring generated by AI.*

        Updates an Arma server by stopping it, downloading the latest server files via SteamCMD,
        redeploying mods, and starting the server again. Requires the `can_manage_server` role
        to execute. Uses Steam credentials from global configuration to authenticate with the
        Creator DLC beta branch.

        **Args:**
        - `server` (`str`): The name of the server to update as defined in the server configuration (path parameter).

        **Returns:**
        - `WebResponse`: HTTP response indicating server update status
          - **Success (200)**: Server updated successfully
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/main_server/update

        Success response (200):
        {
            "message": "Server status checked",
            "server_status": "Running",
            "hc_status": "Running"
        }
        ```
        """
        logger.info(f'User {session_user.id} is trying to update {server}')
        return await ArmaApi().update_server(server)

    @api.post('/<string:server>/update_mods')
    @url_endpoint
    @require_session
    @require_user_role(Roles.can_manage_server)
    async def update_server_mods(session_user: User, server: str) -> WebResponse:
        """
        ### Update mods for a specific Arma server

        *Docstring generated by AI.*

        Updates all mods for the specified server by identifying out-of-date versions, stopping
        all affected servers, downloading updated mods via SteamCMD, then redeploying and
        restarting all servers. Requires the `can_manage_server` role to execute. Only processes
        non-manual mods and handles server dependencies automatically.

        **Args:**
        - `server` (`str`): The name of the server whose mods should be updated as defined in the server configuration.

        **Returns:**
        - `WebResponse`: HTTP response indicating mod update status
          - **Success (200)**: Mods updated successfully for the server
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        POST /api/v1/server_ops/arma/main_server/update_mods

        Success response (200):
        {
            "server_status": [
                {
                    "message": "Server updated",
                    "server_status": "Running",
                    "hc_status": "Running"
                }
            ]
        }
        ```
        """
        logger.info(f'User {session_user.id} is trying to update the mods of {server}')
        return await ArmaApi().update_server_mods(server)

    @api.get('/<string:server>/healthcheck')
    @url_endpoint
    async def healthcheck_server(server: str) -> JsonResponse:
        """
        ### Check server health status

        *Docstring generated by AI.*

        Checks if an Arma server is currently running by querying the server process
        status using the server management PowerShell script. Returns the current
        operational state of the server and headless clients in JSON format.

        **Args:**
        - `server` (`str`): The name of the server to check as defined in the server configuration (path parameter).

        **Returns:**
        - `JsonResponse`: JSON response containing process status
          - **Success (200)**: `{'message': 'Server status checked', 'server_status': 'Running', 'hc_status': 'Running'}`
          - **Error (404)**: HTTP 404 response if server configuration not found
          - **Error (500)**: HTTP 500 response for other server errors

        **Example:**
        ```
        GET /api/v1/server_ops/arma/main_server/healthcheck

        Success response (200):
        {
            "message": "Server status checked",
            "server_status": "Running",
            "hc_status": "Running"
        }
        ```
        """
        logger.info(f'Getting the status of {server}')
        return await ArmaApi().server_pid_status(server)

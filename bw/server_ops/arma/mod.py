import logging
from pathlib import Path
from enum import StrEnum
from dataclasses import dataclass
import datetime
from typing import Any, Self, NewType
from collections.abc import Iterable
from collections.abc import Collection
import asyncio
import aiohttp
import tomllib
import tomli_w

from bw.error.arma_mod import (
    ModNotDefined,
    ModAlreadyDefined,
    ModMissingField,
    ModInvalidKind,
    ModFieldInvalid,
    DuplicateModWorkshopID,
    DuplicateModPath,
    ModAlreadyExists,
)
from bw.state import State

logger = logging.getLogger('bw.server_ops.arma')

# A mapping of all mods by their name.
# An entry is created when a mod is loaded from a mod definition file
MODS: dict[str, 'Mod'] = {}

# A mapping of all modlists by their name.
# An entry is created when a modlist is initialised
MODLISTS: dict[str, 'Modlist'] = {}

WorkshopId = NewType('WorkshopId', int)


@dataclass
class SteamWorkshopDetails:
    workshop_id: WorkshopId
    title: str
    file_size_bytes: int
    last_update: datetime.datetime

    @classmethod
    def from_json(cls, json: dict[str, Any]) -> Self:
        """
        ### Create a SteamWorkshopDetails instance from JSON data

        *Docstring generated by AI.*

        Parses the provided JSON dictionary to create a SteamWorkshopDetails object.
        Extracts workshop ID, title, file size, and last update timestamp from the
        Steam API response format.

        **Async:** No

        **Args:**
        - `json` (`dict[str, Any]`): The JSON data containing workshop details from Steam API.

        **Returns:**
        - `SteamWorkshopDetails`: An instance populated with the data from the JSON.

        **Example:**
        ```python
        details = SteamWorkshopDetails.from_json({
            'publishedfileid': '463939057',
            'title': 'ACE3',
            'file_size': 1024000,
            'time_updated': 1640995200
        })
        # SteamWorkshopDetails(workshop_id=463939057, title='ACE3', ...)
        ```
        """
        return cls(
            workshop_id=WorkshopId(json.get('publishedfileid', -1)),
            title=json.get('title', 'Unknown Title'),
            file_size_bytes=json.get('file_size', 0),
            last_update=datetime.datetime.fromtimestamp(json.get('time_updated', 0)),
        )


async def fetch_mod_details_from_workshop(mods: Collection['Mod']) -> dict[WorkshopId, SteamWorkshopDetails]:
    """
    ### Fetch mod details from Steam Workshop API

    *Docstring generated by AI.*

    Makes an asynchronous HTTP request to the Steam Workshop API to retrieve detailed
    information about mods based on their workshop IDs. Returns a dictionary mapping
    workshop IDs to their corresponding SteamWorkshopDetails objects. Handles API
    errors gracefully by logging warnings and returning an empty dictionary if the
    request fails completely.

    **Async:** Yes

    **Args:**
    - `mods` (`Collection['Mod']`): A collection of Mod objects containing workshop IDs to fetch details for.

    **Returns:**
    - `dict[WorkshopId, SteamWorkshopDetails]`: A dictionary mapping workshop IDs to their Steam Workshop details.

    **Example:**
    ```python
    details = await fetch_mod_details_from_workshop([ace_mod, cba_mod])
    # {WorkshopId(463939057): SteamWorkshopDetails(...), WorkshopId(450814997): SteamWorkshopDetails(...)}
    ```
    """
    mod_workshop_ids: dict[WorkshopId, str] = {
        mod.workshop_id: mod.name for mod in mods if not mod.manual_install and mod.workshop_id is not None
    }

    request_url = 'http://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/'
    params: dict[str, Any] = {
        'itemcount': len(mods),
        **{f'publishedfileids[{idx}]': mod.workshop_id for idx, mod in enumerate(mods)},
    }

    # Get mods name form Steam Workshop
    url = request_url
    logger.info('Fetching mod names from Steam Workshop')
    logger.debug(f'Using URL: {url}')

    details: dict[WorkshopId, SteamWorkshopDetails] = {}
    async with aiohttp.ClientSession() as session:
        async with session.post(url, params=params, data=params) as response:
            if response.status != 200:
                logger.error(f'Failed to fetch mod names ({response.status} {response.reason})')
                return {}
            if response.content_type != 'application/json':
                logger.error(f'Unexpected content type trying to fetch mod names: {response.content_type}')
                return {}

            json = await response.json()
            for file in json['response']['publishedfiledetails']:
                workshop_id = WorkshopId(file['publishedfileid'])
                if 'result' not in file or file['result'] != 1:
                    error_reason = file.get('reason', 'unknown')
                    logger.warning(
                        f'Failed to fetch details for "{mod_workshop_ids[workshop_id]}" ({workshop_id}): {error_reason}'
                    )
                    continue
                if workshop_id not in mod_workshop_ids:
                    logger.warning(f'Workshop ID {workshop_id} not found in loaded mods')
                    continue
                details[workshop_id] = SteamWorkshopDetails.from_json(file)

    return details


def load_mods(mods_file: Path):
    """
    ### Load mod definitions from a TOML configuration file

    *Docstring generated by AI.*

    Parses a TOML configuration file to load mod definitions into the global MODS dictionary.
    Validates all required fields, checks for duplicate workshop IDs and filenames, and fetches
    mod names from the Steam Workshop API. Creates Mod objects with proper directory paths
    based on mod type (regular mod or server mod) and configuration overrides.

    **Async:** No

    **Args:**
    - `mods_file` (`Path`): The path to the TOML file containing mod definitions.

    **Raises:**
    - `ModMissingField`: If required fields are missing from the configuration.
    - `ModFieldInvalid`: If field values have invalid types or formats.
    - `ModAlreadyDefined`: If a mod with the same name is already loaded.
    - `DuplicateModWorkshopID`: If multiple mods share the same workshop ID.
    - `DuplicateModPath`: If multiple mods share the same filename.
    - `ModInvalidKind`: If the mod kind is not a valid Kind enum value.

    **Returns:**
    - `None`: This function modifies the global MODS dictionary and does not return a value.

    **Example:**
    ```python
    load_mods(Path('config/mods.toml'))
    # None
    ```

    Example TOML file:
    ```
        [defaults]
        mod_directory = "/path/to/mods"
        server_mod_directory = "/path/to/server/mods"

        [mod]
        [mod.ace]
        filename = "ace"
        workshop_id = 463939057
        kind = "mod"

        [mod.acre2]
        filename = "acre2"
        workshop_id = 751965892
        manual_install = true

        [mod.cba_a3]
        filename = "cba_a3"
        workshop_id = 450814997
        kind = "server_mod"
        server_mod_directory = "/custom/server/path"

        [mod.custom_mod]
        filename = "custom_mod"
        workshop_id = 123456789
        mod_directory = "/custom/mod/path"
    ```
    """
    mods_added: dict[str, Mod] = {}
    mod_workshop_ids = {mod.workshop_id: mod.name for mod in MODS.values()}
    mod_filenames = {mod.filename: mod.name for mod in MODS.values()}

    with open(mods_file, 'rb') as f:
        config = tomllib.load(f)

    if 'defaults' not in config:
        raise ModMissingField('global', 'defaults')
    if not isinstance(config['defaults'], dict):
        raise ModFieldInvalid('global', 'defaults', 'must be a dictionary')
    if 'mod' not in config:
        raise ModMissingField('global', 'mod')
    if not isinstance(config['mod'], dict):
        raise ModFieldInvalid('global', 'mod', 'must be a dictionary')

    defaults = config['defaults']
    if 'mod_directory' not in defaults:
        raise ModMissingField('defaults', 'mod_directory')
    if not isinstance(defaults['mod_directory'], str):
        raise ModFieldInvalid('defaults', 'mod_directory', 'must be a string')
    if 'server_mod_directory' not in defaults:
        raise ModMissingField('defaults', 'server_mod_directory')
    if not isinstance(defaults['server_mod_directory'], str):
        raise ModFieldInvalid('defaults', 'server_mod_directory', 'must be a string')

    mod_list: dict[str, str] = config['mod']

    for mod_name, mod_data in mod_list.items():
        # Check if mod already exists
        mod_name = mod_name.replace('-', ' ').strip()
        if mod_name in MODS:
            raise ModAlreadyDefined(mod_name)

        # Check required fields
        if 'filename' not in mod_data:
            raise ModMissingField(mod_name, 'filename')
        if not isinstance(mod_data['filename'], str):
            raise ModFieldInvalid(mod_name, 'filename', 'must be a string')

        if 'workshop_id' not in mod_data:
            raise ModMissingField(mod_name, 'workshop_id')
        if not isinstance(mod_data['workshop_id'], int):
            raise ModFieldInvalid(mod_name, 'workshop_id', 'must be an integer')

        workshop_id_str = str(mod_data['workshop_id'])
        if workshop_id_str in mod_workshop_ids:
            raise DuplicateModWorkshopID(mod_data['workshop_id'], mod_name, mod_workshop_ids[workshop_id_str])
        mod_workshop_ids[workshop_id_str] = mod_name

        filename = mod_data['filename']
        if filename in mod_filenames:
            raise DuplicateModPath(mod_name, mod_filenames[filename], filename)
        mod_filenames[filename] = mod_name

        if 'manual_install' in mod_data and not isinstance(mod_data['manual_install'], bool):
            raise ModFieldInvalid(mod_name, 'manual_install', 'must be a boolean')
        if 'kind' in mod_data and not isinstance(mod_data['kind'], str):
            raise ModFieldInvalid(mod_name, 'kind', 'must be a string')

        # Validate kind if present
        kind_str = mod_data.get('kind', Kind.MOD)
        try:
            kind = Kind(kind_str)
        except ValueError as e:
            raise ModInvalidKind(mod_name, kind_str, list(Kind)) from e

        if kind == Kind.SERVER_MOD:
            directory = Path(defaults['server_mod_directory'])
            if 'server_mod_directory' in mod_data:
                if not isinstance(mod_data['server_mod_directory'], str):
                    raise ModFieldInvalid(mod_name, 'server_mod_directory', 'must be a string')
                directory = Path(mod_data['server_mod_directory'])
        else:
            directory = Path(defaults['mod_directory'])
            if 'mod_directory' in mod_data:
                if not isinstance(mod_data['mod_directory'], str):
                    raise ModFieldInvalid(mod_name, 'mod_directory', 'must be a string')
                directory = Path(mod_data['mod_directory'])

        mod = Mod(
            filename=mod_data['filename'],
            workshop_id=mod_data['workshop_id'],
            kind=kind,
            directory=directory,
            manual_install=mod_data.get('manual_install', False),
            name=mod_name,
        )
        MODS[mod_name] = mod
        mods_added[mod_name] = mod

    async def update_mod_details():
        from bw.server_ops.arma.mod_store import ModStore

        if mods_added:
            logger.info('Fetching mod details from Steam Workshop')
            details = await fetch_mod_details_from_workshop(mods_added.values())
        else:
            logger.info('No mods to fetch details for')
            return

        for mod_name, mod in mods_added.items():
            if mod.workshop_id:
                detail = details.get(mod.workshop_id)
                mod.name = detail.title if detail else mod_name

                if detail:
                    logger.info(f'Attempting to store {mod.name} into DB')
                    try:
                        ModStore().create_mod(State.state, detail)
                    except ModAlreadyExists:
                        logger.info(f'{mod.name} has already been defined!')

    asyncio.run(update_mod_details())


def save_mods(config_path: Path):
    """
    ### Save mod definitions to a TOML configuration file

    *Docstring generated by AI.*

    Persists the current state of the global MODS dictionary to a TOML file. Extracts
    default directories from existing mods and writes each mod's configuration including
    filename, workshop ID, kind, manual install flag, and any custom directory overrides.
    The output format matches what load_mods() expects for reading configurations.

    **Async:** No

    **Args:**
    - `config_path` (`Path`): The path to write the TOML configuration file to.

    **Returns:**
    - `None`: This function writes to disk and does not return a value.

    **Example:**
    ```python
    save_mods(Path('config/mods.toml'))
    # None
    ```

    Output TOML file structure:
    ```
    [defaults]
    mod_directory = "/path/to/mods"
    server_mod_directory = "/path/to/server/mods"

    [mod]
    [mod.ace]
    filename = "ace"
    workshop_id = 463939057
    kind = "mod"

    [mod.cba_a3]
    filename = "cba_a3"
    workshop_id = 450814997
    kind = "server_mod"
    manual_install = true
    ```
    """
    if not MODS:
        logger.warning('No mods to save')
        return

    # Determine default directories from existing mods
    # Use the most common directories, or fallback to first mod's directory
    mod_directories = [mod.directory for mod in MODS.values() if mod.kind == Kind.MOD]
    server_mod_directories = [mod.directory for mod in MODS.values() if mod.kind == Kind.SERVER_MOD]

    # Find most common directory, or use first one, or use empty string
    default_mod_dir = str(mod_directories[0]) if mod_directories else ''
    default_server_mod_dir = str(server_mod_directories[0]) if server_mod_directories else ''

    # Build TOML structure
    config = {
        'defaults': {
            'mod_directory': default_mod_dir,
            'server_mod_directory': default_server_mod_dir,
        },
        'mod': {},
    }

    # Add each mod to config
    for mod_name, mod in MODS.items():
        # Convert mod name to TOML key format (replace spaces with dashes)
        mod_key = mod_name.replace(' ', '-')

        mod_config = {
            'filename': mod.filename,
            'workshop_id': int(mod.workshop_id) if mod.workshop_id else 0,
            'kind': mod.kind.value,
        }

        # Add optional fields
        if mod.manual_install:
            mod_config['manual_install'] = True

        # Add custom directory overrides if different from defaults
        if mod.kind == Kind.MOD:
            if str(mod.directory) != default_mod_dir:
                mod_config['mod_directory'] = str(mod.directory)
        elif mod.kind == Kind.SERVER_MOD:
            if str(mod.directory) != default_server_mod_dir:
                mod_config['server_mod_directory'] = str(mod.directory)

        config['mod'][mod_key] = mod_config

    # Write to file
    logger.info(f'Saving {len(MODS)} mods to {config_path}')
    config_path.parent.mkdir(parents=True, exist_ok=True)

    with open(config_path, 'wb') as f:
        tomli_w.dump(config, f)

    logger.info(f'Successfully saved mods to {config_path}')


def save_modlists(config_path: Path):
    """
    ### Save modlist definitions to text files

    *Docstring generated by AI.*

    Persists the current state of the global MODLISTS dictionary to text files in the
    specified directory. Each modlist is saved as a separate text file containing mod
    names, one per line. The filename is derived from the modlist name with '.txt'
    extension. The output format matches what Modlist() expects when loading from files.

    **Async:** No

    **Args:**
    - `config_path` (`Path`): The directory path where modlist text files should be written.

    **Returns:**
    - `None`: This function writes to disk and does not return a value.

    **Example:**
    ```python
    save_modlists(Path('config/modlists'))
    # None
    ```

    Output file structure (e.g., 'config/modlists/main_mods.txt'):
    ```
    ace
    cba_a3
    acre2
    ```
    """
    if not MODLISTS:
        logger.warning('No modlists to save')
        return

    # Ensure directory exists
    config_path.mkdir(parents=True, exist_ok=True)

    logger.info(f'Saving {len(MODLISTS)} modlists to {config_path}')

    for modlist_name, modlist in MODLISTS.items():
        # Create filename from modlist name (sanitize for filesystem)
        filename = modlist_name.replace(' ', '_').replace('/', '_') + '.txt'
        file_path = config_path / filename

        # Write mod names to file, one per line
        with open(file_path, 'w') as f:
            for mod in modlist.mods:
                f.write(f'{mod.name}\n')

        logger.debug(f'Saved modlist "{modlist_name}" with {len(modlist.mods)} mods to {file_path}')

    logger.info(f'Successfully saved modlists to {config_path}')


def load_modlists(config_path: Path):
    """
    ### Load modlist definitions from text files in a directory

    *Docstring generated by AI.*

    Scans the specified directory for .txt files and creates Modlist objects from each
    file. Each text file should contain mod names (one per line) that reference mods
    already loaded in the global MODS dictionary. The modlist name is derived from the
    filename without the .txt extension.

    **Async:** No

    **Args:**
    - `config_path` (`Path`): The directory path containing modlist text files.

    **Raises:**
    - `ModNotDefined`: If a mod name in any file is not found in the global MODS dictionary.

    **Returns:**
    - `None`: This function modifies the global MODLISTS dictionary and does not return a value.

    **Example:**
    ```python
    load_modlists(Path('config/modlists'))
    # None
    ```

    Expected directory structure:
    ```
    config/modlists/
    ├── main_mods.txt
    ├── training_mods.txt
    └── event_mods.txt
    ```
    """
    if not config_path.exists():
        logger.warning(f'Modlist directory does not exist: {config_path}')
        return

    if not config_path.is_dir():
        logger.error(f'Modlist path is not a directory: {config_path}')
        return

    # Find all .txt files in directory
    modlist_files = list(config_path.glob('*.txt'))

    if not modlist_files:
        logger.warning(f'No modlist files found in {config_path}')
        return

    logger.info(f'Loading {len(modlist_files)} modlists from {config_path}')

    for modlist_file in modlist_files:
        # Extract modlist name from filename (remove .txt extension)
        modlist_name = modlist_file.stem.replace('_', ' ')

        try:
            Modlist(modlist_name, file=modlist_file)
            logger.debug(f'Loaded modlist "{modlist_name}" from {modlist_file}')
        except ModNotDefined as e:
            logger.error(f'Failed to load modlist "{modlist_name}": {e}')
            raise

    logger.info(f'Successfully loaded {len(modlist_files)} modlists')


class Kind(StrEnum):
    MOD = 'mod'
    SERVER_MOD = 'server_mod'


@dataclass
class Mod:
    directory: Path = Path('')
    name: str = ''
    filename: str = ''
    workshop_id: WorkshopId | None = None
    manual_install: bool = False
    kind: Kind = Kind.MOD

    def as_launch_parameter(self) -> str:
        """
        ### Generate launch parameter string for the mod

        *Docstring generated by AI.*

        Creates the command-line parameter format used when launching Arma 3 with this mod.
        Prefixes the filename with '@' symbol following Arma 3 mod parameter conventions.

        **Async:** No

        **Returns:**
        - `str`: The mod launch parameter in format '@filename'.

        **Example:**
        ```python
        mod = Mod(filename='ace')
        param = mod.as_launch_parameter()
        # '@ace'
        ```
        """
        return f'@{self.filename}'

    def path(self) -> Path:
        """
        ### Get the full filesystem path to the mod directory

        *Docstring generated by AI.*

        Combines the mod's base directory with its launch parameter to create the full
        path where the mod is installed. This is typically used to locate mod files
        on the filesystem.

        **Async:** No

        **Returns:**
        - `Path`: The complete path to the mod directory.

        **Example:**
        ```python
        mod = Mod(directory=Path('/mods'), filename='ace')
        mod_path = mod.path()
        # Path('/mods/@ace')
        ```
        """
        return self.directory / self.as_launch_parameter()

    def as_html(self) -> str:
        """
        ### Generate HTML representation of the mod

        *Docstring generated by AI.*

        Creates an HTML representation of the mod by reading a template file and
        formatting it with the mod's name and workshop ID. Used for displaying
        mod information in web interfaces.

        **Async:** No

        **Returns:**
        - `str`: The HTML string representing this mod.

        **Example:**
        ```python
        mod = Mod(name='ACE3', workshop_id='463939057')
        html = mod.as_html()
        # '<div class="mod">...</div>'
        ```
        """
        with open(Path('static/templates/arma/mod.html')) as f:
            return f.read().format(
                mod_name=self.name,
                workshop_id=self.workshop_id,
            )


class Modlist:
    _name: str
    _mods: list[Mod]

    def __init__(self, name: str, file: Path | None = None, mods: list[str] | None = None):
        """
        ### Initialize a modlist from a file

        *Docstring generated by AI.*

        Creates a new Modlist instance by reading mod names from a text file. Each line
        in the file should contain the name of a mod that exists in the global MODS
        dictionary. Registers the modlist in the global MODLISTS dictionary for later access.

        **Async:** No

        **Args:**
        - `name` (`str`): The name to assign to this modlist.
        - `file` (`Path`): The path to the text file containing mod names, one per line.

        **Raises:**
        - `ModNotDefined`: If a mod name in the file is not found in the global MODS dictionary.

        **Returns:**
        - `None`: This is a constructor that initializes the instance.

        **Example:**
        ```python
        modlist = Modlist('main_mods', Path('config/main.txt'))
        # Modlist instance created and registered in MODLISTS['main_mods']
        ```
        """
        self._name = name
        self._mods = []
        if file:
            with open(file) as f:
                for mod in f:
                    mod = mod.strip()
                    if mod not in MODS:
                        raise ModNotDefined(mod)
                    self._mods.append(MODS[mod])
        elif mods:
            self._mods = mods

        MODLISTS[self._name] = self

    @property
    def name(self) -> str:
        """
        ### Get the name of the modlist

        Returns the name of the modlist

        **Async:** No

        **Returns:**
        - `str`: The modlist name.

        **Example:**
        ```python
        modlist = Modlist('main_mods', Path('config/main.txt'))
        name = modlist.name
        # main_mods
        ```
        """
        return self._name

    @property
    def mods(self) -> list[Mod]:
        """
        ### Get the list of mods in this modlist

        *Docstring generated by AI.*

        Returns the list of Mod objects that are included in this modlist. This is
        a read-only property that provides access to the internal mod list.

        **Async:** No

        **Returns:**
        - `list[Mod]`: The list of Mod objects in this modlist.

        **Example:**
        ```python
        modlist = Modlist('main_mods', Path('config/main.txt'))
        mods = modlist.mods
        # [Mod(...), Mod(...), ...]
        ```
        """
        return self._mods

    def as_html(self, preset_name: str | None = None) -> str:
        """
        ### Generate HTML representation of the modlist

        *Docstring generated by AI.*

        Creates an HTML representation of the entire modlist by combining CSS styles
        with individual mod HTML representations. Uses template files to format the
        output for web display.

        **Async:** No

        **Args:**
        - `preset_name` (`str | None`): Optional override name for the modlist display. If None, uses the modlist's name.

        **Returns:**
        - `str`: The complete HTML string representing this modlist.

        **Example:**
        ```python
        modlist = Modlist('main_mods', Path('config/main.txt'))
        html = modlist.as_html('Custom Preset Name')
        # '<html><head><style>...</style></head><body>...</body></html>'
        ```
        """
        with open(Path('static/templates/arma/style.css')) as f:
            style = f.read()
        mod_html = ''.join(mod.as_html() for mod in self._mods)
        with open(Path('static/templates/arma/modlist.html')) as f:
            return f.read().format(
                style=style,
                modlist_name=self._name if preset_name is None else preset_name,
                html_mods=mod_html,
            )

    def has_mods_from(self, other: Self | Iterable[Mod]) -> bool:
        """
        ### Check if this modlist contains any mods from another modlist

        *Docstring generated by AI.*

        Determines whether this modlist shares any mods with another modlist by checking
        if any mod objects from the other modlist are present in this modlist. Used to
        identify server dependencies when updating mods.

        **Async:** No

        **Args:**
        - `other` (`Modlist`): The other modlist to compare against.

        **Returns:**
        - `bool`: True if this modlist contains any mods from the other modlist, False otherwise.

        **Example:**
        ```python
        modlist1 = Modlist('server1_mods', Path('config/server1.txt'))
        modlist2 = Modlist('server2_mods', Path('config/server2.txt'))
        has_shared = modlist1.has_mods_from(modlist2)
        # True or False
        ```
        """
        if isinstance(other, Modlist):
            mods = other.mods
        elif isinstance(other, Iterable):
            mods = list(other)
        else:
            raise TypeError(f'Expected Modlist or Iterable[Mod], got {type(other).__name__}')
        return any(mod in self._mods for mod in mods)

from collections.abc import Iterable
from sqlalchemy import select, delete, or_
from sqlalchemy.exc import IntegrityError

from bw.server_ops.arma.mod import SteamWorkshopDetails, WorkshopId, Mod
from bw.state import State
from bw.models.arma import Mod as DbMod
from bw.error.arma_mod import (
    ModFieldInvalid,
    ModAlreadyExists,
    ModNotFound,
)


class ModStore:
    def create_mod(self, state: State, workshop_details: SteamWorkshopDetails) -> DbMod:
        """
        ### Create a new mod record in the database

        *Docstring generated by AI.*

        Creates a new database record for a mod using Steam Workshop details. This is used
        to track mod update timestamps locally for event notifications. The method converts
        the SteamWorkshopDetails to a DbMod object using the from_workshop_details class
        method, then attempts to insert it into the database. If a mod with the same workshop
        ID already exists, raises ModAlreadyExists due to the unique constraint.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `workshop_details` (`SteamWorkshopDetails`): The Steam Workshop details containing mod information.

        **Raises:**
        - `ModAlreadyExists`: If a mod with the same workshop ID already exists in the database.
        - `ModCreationFailed`: If the mod creation fails for any other database constraint violation.

        **Returns:**
        - `DbMod`: The created database mod object.

        **Example:**
        ```python
        details = SteamWorkshopDetails(workshop_id=463939057, title='ACE3', ...)
        db_mod = mod_store.create_mod(state, details)
        # DbMod(id=1, workshop_id=463939057, ...)
        ```
        """
        with state.Session.begin() as session:
            db_mod = DbMod.from_workshop_details(workshop_details)
            db_mod.last_update_date = None
            try:
                session.add(db_mod)
                session.flush()
            except IntegrityError as e:
                raise ModAlreadyExists(workshop_details.workshop_id) from e
            session.expunge(db_mod)
        return db_mod

    def get_mod_by_workshop_id(self, state: State, workshop_id: WorkshopId) -> DbMod:
        """
        ### Retrieve a mod by its workshop ID

        *Docstring generated by AI.*

        Queries the database for a mod record with the specified Steam Workshop ID.
         If no record exists, raises ModNotFound.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `workshop_id` (`WorkshopId`): The Steam Workshop ID of the mod to retrieve.

        **Raises:**
        - `ModNotFound`: If no mod with the given workshop ID exists in the database.

        **Returns:**
        - `DbMod`: The mod record from the database.

        **Example:**
        ```python
        db_mod = mod_store.get_mod_by_workshop_id(state, WorkshopId(463939057))
        # DbMod(id=1, workshop_id=463939057, ...)
        ```
        """
        with state.Session.begin() as session:
            query = select(DbMod).where(DbMod.workshop_id == workshop_id)
            result = session.execute(query).first()
            if result is None:
                raise ModNotFound(workshop_id)
            session.expunge(result[0])
        return result[0]

    def update_mod(self, state: State, mod_data: SteamWorkshopDetails) -> DbMod:
        """
        ### Update or create a mod record from workshop details or mod object

        *Docstring generated by AI.*

        Updates an existing mod record in the database using Steam Workshop object.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `mod_data` (`SteamWorkshopDetails`): Steam Workshop details to update from.

        **Raises:**
        - `ModNotFound`: If no database record exists for the workshop ID.

        **Returns:**
        - `DbMod`: The updated database mod object.

        **Example:**
        ```python
        # Using SteamWorkshopDetails
        details = SteamWorkshopDetails(workshop_id=463939057, title='ACE3', ...)
        db_mod = mod_store.update_mod(state, details)
        # DbMod(id=1, workshop_id=463939057, ...)
        ```
        """
        with state.Session.begin() as session:
            query = select(DbMod).where(DbMod.workshop_id == mod_data.workshop_id)
            result = session.execute(query).first()

            if result is None:
                raise ModNotFound(mod_data.workshop_id)

            db_mod = result[0]
            db_mod.last_update_date = int(mod_data.last_update.timestamp())

            session.flush()
            session.expunge(db_mod)
        return db_mod

    def get_out_of_date_mods(self, state: State, mods_to_check: Iterable[SteamWorkshopDetails]) -> list[DbMod]:
        """
        ### Find mods that have newer versions available on Steam Workshop

        *Docstring generated by AI.*

        Compares local mod records against Steam Workshop details to identify mods that
        have been updated on Steam Workshop since they were last checked. For each mod
        in the input list, queries the database for a record with matching workshop ID
        and checks if the local last_update_date is older than the Steam Workshop
        last_update timestamp. Returns all database records that are out of date.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `mods_to_check` (`Iterable[SteamWorkshopDetails]`): Collection of Steam Workshop details to check against local records.

        **Returns:**
        - `list[DbMod]`: A list of database mod records that have newer versions available on Steam Workshop.

        **Example:**
        ```python
        steam_details = [SteamWorkshopDetails(workshop_id=463939057, last_update=datetime.now(), ...)]
        out_of_date = mod_store.get_out_of_date_mods(state, steam_details)
        # [DbMod(id=1, workshop_id=463939057, last_update_date=1640995200, ...)]
        ```
        """
        out_of_date_mods = []
        with state.Session.begin() as session:
            for mod in mods_to_check:
                query = (
                    select(DbMod)
                    .where(DbMod.workshop_id == mod.workshop_id)
                    .where(or_(DbMod.last_update_date.is_(None), DbMod.last_update_date < int(mod.last_update.timestamp())))
                )
                out_of_date_mods.extend(session.scalars(query).all())
            session.expunge_all()
        return out_of_date_mods

    def get_all_mods(self, state: State) -> list[DbMod]:
        """
        ### Retrieve all mod records from the database

        *Docstring generated by AI.*

        Returns all mod records stored in the database, ordered by workshop ID.
        Used for bulk operations or when checking the entire mod catalog for updates.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.

        **Returns:**
        - `list[DbMod]`: A list of all mod records in the database, ordered by workshop ID.

        **Example:**
        ```python
        all_mods = mod_store.get_all_mods(state)
        # [DbMod(id=1, workshop_id=463939057, ...), DbMod(id=2, workshop_id=450814997, ...), ...]
        ```
        """
        with state.Session.begin() as session:
            query = select(DbMod).order_by(DbMod.workshop_id)
            results = session.execute(query).all()
            for result in results:
                session.expunge(result[0])
        return [result[0] for result in results]

    def delete_mod(self, state: State, workshop_id: WorkshopId | Mod | SteamWorkshopDetails):
        """
        ### Delete a mod record from the database

        *Docstring generated by AI.*

        Removes a mod record from the database based on its workshop ID. Accepts multiple
        input types for convenience - a WorkshopId directly, a Mod object, or
        SteamWorkshopDetails object. The workshop ID is extracted from object types
        automatically. This should be used when a mod is no longer being tracked or
        has been removed from the server configuration.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `workshop_id` (`WorkshopId | Mod | SteamWorkshopDetails`): The workshop element to delete.

        **Raises:**
        - `ModFieldInvalid`: If a Mod object is provided but has no workshop_id field.

        **Example:**
        ```python
        # Using WorkshopId directly
        mod_store.delete_mod(state, WorkshopId(463939057))

        # Using Mod object
        mod_store.delete_mod(state, mod_object)

        # Using SteamWorkshopDetails object
        mod_store.delete_mod(state, workshop_details)
        # Mod record deleted from database
        ```
        """
        if isinstance(workshop_id, Mod):
            if workshop_id.workshop_id is None:
                raise ModFieldInvalid(workshop_id.name or 'unknown', 'workshop_id', 'must not be `None` for database deletions')
            workshop_id = workshop_id.workshop_id
        elif isinstance(workshop_id, SteamWorkshopDetails):
            workshop_id = workshop_id.workshop_id

        with state.Session.begin() as session:
            query = delete(DbMod).where(DbMod.workshop_id == workshop_id)
            session.execute(query)

    def bulk_update_mods(self, state: State, workshop_details_list: Iterable[SteamWorkshopDetails]) -> list[DbMod]:
        """
        ### Update multiple mod records in a single transaction

        *Docstring generated by AI.*

        Efficiently updates multiple mod records in the database using a single transaction.
        For each SteamWorkshopDetails in the list, looks up the existing mod record by
        workshop ID. If a record exists, updates its last_update_date with the new timestamp.
        If no record exists for a workshop ID, raises ModNotFound. All operations are
        performed within a single database transaction.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `workshop_details_list` (`list[SteamWorkshopDetails]`): A list of Steam Workshop details to update.

        **Raises:**
        - `ModNotFound`: If any workshop ID in the list does not have an existing database record.

        **Returns:**
        - `list[DbMod]`: A list of all updated database mod objects in the same order as input.

        **Example:**
        ```python
        details_list = [SteamWorkshopDetails(...), SteamWorkshopDetails(...)]
        updated_mods = mod_store.bulk_update_mods(state, details_list)
        # [DbMod(id=1, ...), DbMod(id=2, ...), ...]
        ```
        """
        updated_mods = []

        with state.Session.begin() as session:
            for workshop_details in workshop_details_list:
                query = select(DbMod).where(DbMod.workshop_id == workshop_details.workshop_id)
                result = session.execute(query).first()

                if result is None:
                    raise ModNotFound(workshop_details.workshop_id)
                else:
                    db_mod = result[0]
                    db_mod.last_update_date = int(workshop_details.last_update.timestamp())

                updated_mods.append(db_mod)

            session.flush()
            for db_mod in updated_mods:
                session.expunge(db_mod)

        return updated_mods

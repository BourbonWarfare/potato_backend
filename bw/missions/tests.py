from uuid import UUID
from sqlalchemy import delete, select
from sqlalchemy.exc import NoResultFound, IntegrityError

from bw.state import State
from bw.models.auth import User
from bw.models.missions import Review, Iteration, TestResult, TestCosign
from bw.error import CouldNotCreateTestResult, CouldNotCosignResult, NoReviewFound, NoResultFound as NoTestResultFound
from bw.missions.test_status import TestStatus, Review as IterationReview


class TestStore:
    def create_review(self, state: State, tester: User, test_status: TestStatus, notes: dict) -> Review:
        """
        ### Create a new review for a mission iteration

        *Docstring generated by AI.*

        Creates a new review record for a mission iteration with the specified status and notes.
        The review is immediately persisted to the database.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `tester` (`User`): The user performing the review.
        - `test_status` (`TestStatus`): The status of the test (e.g., passed, failed).
        - `notes` (`dict`): Additional notes for the review.

        **Returns:**
        - `Review`: The created review object.

        **Example:**
        ```python
        review = TestStore().create_review(state, user, TestStatus.PASSED, {'briefing': 'good'})
        # Review object
        ```
        """
        with state.Session.begin() as session:
            review = Review(tester_id=tester.id, status=test_status, notes=notes)
            session.add(review)
            session.flush()
            session.expunge(review)
        return review

    def change_review_status(self, state: State, tester: User, iteration: Iteration, new_status: TestStatus):
        """
        ### Change the status of a review

        *Docstring generated by AI.*

        Changes the status of a review for a given tester and iteration.
        Raises `NoReviewFound` if no review exists for the tester and iteration.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `tester` (`User`): The user whose review status is to be changed.
        - `iteration` (`Iteration`): The mission iteration being reviewed.
        - `new_status` (`TestStatus`): The new status to set for the review.

        **Raises:**
        - `NoReviewFound`: If no review exists for the tester and iteration.

        **Example:**
        ```python
        TestStore().change_review_status(state, user, iteration, TestStatus.FAILED)
        # No return value
        ```
        """
        with state.Session.begin() as session:
            query = (
                select(Review)
                .join(TestResult, TestResult.review_id == Review.id)
                .where(Review.tester_id == tester.id)
                .where(TestResult.iteration_id == iteration.id)
            )
            try:
                review = session.execute(query).one()[0]
            except NoResultFound:
                raise NoReviewFound()
            review.status = new_status

    def create_result(self, state: State, iteration: Iteration, review: Review) -> TestResult:
        """
        ### Create a new test result

        *Docstring generated by AI.*

        Creates a new test result for a given iteration and review.
        Raises `CouldNotCreateTestResult` if a result cannot be created due to a constraint violation.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `iteration` (`Iteration`): The mission iteration being tested.
        - `review` (`Review`): The review associated with the test result.

        **Returns:**
        - `TestResult`: The created test result object.

        **Raises:**
        - `CouldNotCreateTestResult`: If a result cannot be created due to a constraint violation.

        **Example:**
        ```python
        result = TestStore().create_result(state, iteration, review)
        # TestResult object
        ```
        """
        with state.Session.begin() as session:
            result = TestResult(review_id=review.id, iteration_id=iteration.id)
            try:
                session.add(result)
                session.flush()
            except IntegrityError:
                raise CouldNotCreateTestResult()
            session.expunge(result)
        return result

    def result_by_uuid(self, state: State, uuid: UUID) -> TestResult:
        """
        ### Retrieve existing test result via its UUID

        *Docstring generated by AI.*

        Retrieves a test result from the database using its UUID.
        before being returned. Raises `NoTestResultFound` if no result with the given UUID exists.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `uuid` (`UUID`): The UUID of the test result to retrieve.

        **Returns:**
        - `TestResult`: The test result object if found.

        **Raises:**
        - `NoTestResultFound`: If no test result with the given UUID exists.

        **Example:**
        ```python
        result = TestStore().result_by_uuid(state, uuid.UUID('12345678-1234-5678-9abc-123456789abc'))
        # TestResult object
        ```
        """
        with state.Session.begin() as session:
            query = select(TestResult).where(TestResult.uuid == uuid)
            try:
                review = session.execute(query).one()[0]
            except NoResultFound:
                raise NoTestResultFound()
            session.expunge(review)
        return review

    def cosign_result(self, state: State, tester: User, test_result: TestResult) -> TestCosign:
        """
        ### Add a cosign to a test result

        *Docstring generated by AI.*

        Adds a cosign to a test result by a tester. The cosign is immediately persisted to the database
        Raises `CouldNotCosignResult` if the tester is the original reviewer or if a cosign constraint is violated.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `tester` (`User`): The user cosigning the test result.
        - `test_result` (`TestResult`): The test result to cosign.

        **Returns:**
        - `TestCosign`: The created cosign object.

        **Raises:**
        - `CouldNotCosignResult`: If the tester is the original reviewer or a cosign constraint is violated.

        **Example:**
        ```python
        cosign = TestStore().cosign_result(state, user, test_result)
        # TestCosign object
        ```
        """
        if test_result.review_id == tester.id:
            raise CouldNotCosignResult()

        with state.Session.begin() as session:
            review = TestCosign(test_result_id=test_result.id, tester_id=tester.id)
            try:
                session.add(review)
                session.flush()
            except IntegrityError:
                raise CouldNotCosignResult()
            session.expunge(review)
        return review

    def remove_cosign(self, state: State, tester: User, test_result: TestResult):
        """
        ### Remove a cosign from a test result

        *Docstring generated by AI.*

        Removes a cosign from a test result for a specific tester. The operation is performed
        within a database transaction and permanently removes the cosign association.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `tester` (`User`): The user whose cosign is to be removed.
        - `test_result` (`TestResult`): The test result from which to remove the cosign.

        **Example:**
        ```python
        TestStore().remove_cosign(state, user, test_result)
        # No return value
        ```
        """
        with state.Session.begin() as session:
            query = delete(TestCosign).where(TestCosign.tester_id == tester.id).where(TestCosign.test_result_id == test_result.id)
            session.execute(query)

    def iteration_reviews(self, state: State, iteration: Iteration) -> list[IterationReview]:
        """
        ### Retrieve all reviews and cosigns for a mission iteration

        *Docstring generated by AI.*

        Returns all reviews and cosigns for the reviews given a mission iteration. Reviews are ordered
        by date tested in descending order. Each review includes associated cosign information.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `iteration` (`Iteration`): The mission iteration for which to retrieve reviews.

        **Returns:**
        - `list[IterationReview]`: A list of `IterationReview` objects containing review and cosign information.

        **Example:**
        ```python
        reviews = TestStore().iteration_reviews(state, iteration)
        # list[IterationReview] with review and cosign data
        ```
        """
        with state.Session.begin() as session:
            query = (
                select(TestResult.id, TestResult.uuid, TestResult.date_tested, Review.status, Review.notes, Review.tester_id)
                .join(Review, TestResult.review_id == Review.id)
                .where(TestResult.iteration_id == iteration.id)
                .order_by(TestResult.date_tested.desc())
            )
            try:
                reviews = session.execute(query).all()
            except NoResultFound:
                return []

            iteration_reviews = []
            for result_id, result_uuid, date_tested, status, notes, tester in reviews:
                query = select(TestCosign.tester_id).where(TestCosign.test_result_id == result_id)
                try:
                    cosigns = [row[0] for row in session.execute(query).all()]
                except NoResultFound:
                    cosigns = []
                iteration_reviews.append(
                    IterationReview(
                        uuid=result_uuid,
                        date_tested=date_tested,
                        status=status,
                        notes=notes,
                        original_tester_id=tester,
                        cosign_ids=cosigns,
                    )
                )
        return iteration_reviews

    def get_test_result_by_user(self, state: State, iteration: Iteration, tester: User) -> TestResult:
        """
        ### Retrieve a test result by user for a mission iteration

        *Docstring generated by AI.*

        Retrieves the test result for a mission iteration by a specific user.
        Raises `NoTestResultFound` if no result exists for
        the user and iteration.

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `iteration` (`Iteration`): The mission iteration being tested.
        - `tester` (`User`): The user whose test result is to be retrieved.

        **Returns:**
        - `TestResult`: The test result object.

        **Raises:**
        - `NoTestResultFound`: If no test result exists for the user and iteration.

        **Example:**
        ```python
        result = TestStore().get_test_result_by_user(state, iteration, user)
        # TestResult object
        ```
        """
        with state.Session.begin() as session:
            query = (
                select(TestResult)
                .join(Review, TestResult.review_id == Review.id)
                .where(TestResult.iteration_id == iteration.id)
                .where(Review.tester_id == tester.id)
            )
            try:
                result = session.execute(query).one()[0]
            except NoResultFound:
                raise NoTestResultFound()
            session.expunge(result)
        return result

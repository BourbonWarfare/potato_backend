import logging
import uuid
from quart import Blueprint

from bw.web_utils import json_endpoint, url_endpoint
from bw.response import JsonResponse, WebResponse
from bw.models.auth import User
from bw.auth.decorators import require_session, require_local, require_user_role, with_token
from bw.auth.permissions import Permissions
from bw.auth.roles import Roles
from bw.auth.api import AuthApi
from bw.state import State


logger = logging.getLogger('bw.auth')

"""
Authentication & Authorization Endpoints Summary:

API Endpoints:
- GET /auth/login/discord - Endpoint for Discord OAuth2 login flow
- POST /api/v1/auth/login/bot - Authenticate bot user and create API session
- GET /api/v1/user/ - Get authenticated user information
- POST /api/v1/user/role/create - Create a new role (requires can_create_role)
- POST /api/v1/user/role/assign - Assign role to user (requires can_create_role)
- POST /api/v1/group/create/permission - Create group permission (requires can_create_group)
- POST /api/v1/group/create - Create new group (requires can_create_group)
- POST /api/v1/group/join - Join a group
- POST /api/v1/group/leave - Leave a group

Local Endpoints:
- POST /api/local/user/create/bot - Create new bot user (local only)
- POST /api/local/user/role/create - Create role (local only, requires session)
- POST /api/local/user/role/assign - Assign role to user (local only, requires session)
"""


def define_auth(api: Blueprint, local: Blueprint, html: Blueprint):
    @api.post('/login/discord')
    @json_endpoint
    @with_token
    async def login_discord(token) -> JsonResponse:
        """
        ### Redirect for Discord OAuth2

        Log in the Discord user via their access token.
        If the users access token is expired, we return 401
        We use the access token to identify the user

        **Args:**
        - None

        **Returns:**
        - `JsonResponse`:
          - **Success (200)**: `{ 'session_token': 'potato' }`
          - **Error (401)**: `{'status': 401, 'reauth_url': 'Discord OAuth'}`

        **Example:**
        ```
        POST /api/v1/auth/login/discord
        Authorization: Bearer potato
        ```
        """
        logger.info('Creating new session (Discord)')
        return await AuthApi().login_with_discord(state=State.state, token=token)

    @api.post('/login/bot')
    @json_endpoint
    async def login_bot(bot_token: str) -> JsonResponse:
        """
        ### Log in with bot token

        *Docstring generated by AI.*

        Authenticates a bot user and creates a new API session.

        **Args:**
        - `bot_token` (`str`): The bot token for authentication.

        **Returns:**
        - `JsonResponse`:
          - **Success (200)**: `{'session_token': str, 'expire_time': str}`
          - **Error (404)**: `{'status': 404, 'reason': 'User does not exist'}`

        **Example:**
        ```
        POST /api/v1/auth/login/bot
        {
            "bot_token": "your_bot_token_here"
        }
        ```
        """
        logger.info('Creating new session (bot)')
        return AuthApi().login_with_bot(state=State.state, bot_token=bot_token)


def define_user(api: Blueprint, local: Blueprint, html: Blueprint):
    local_role_blueprint = Blueprint('local_role', __name__, url_prefix='/role')
    role_blueprint = Blueprint('role', __name__, url_prefix='/role')

    @api.get('/')
    @url_endpoint
    @require_session
    async def get_user_info(session_user: User) -> JsonResponse:
        """
        ### Get user information

        *Docstring generated by AI.*

        Retrieves information about the authenticated user.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).

        **Returns:**
        - `JsonResponse`: A JSON response containing user information.

        **Example:**
        ```
        GET /api/v1/user/
        ```
        """
        return AuthApi().user_info(state=State.state, user=session_user)

    @role_blueprint.post('/create')
    @json_endpoint
    @require_session
    @require_user_role(Roles.can_create_role)
    async def create_role(session_user: User, role_name: str, **kwargs) -> JsonResponse:
        """
        ### Create a new role

        *Docstring generated by AI.*

        Creates a new role with the specified name and role permissions. Requires an active session.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).
        - `role_name` (`str`): The name of the role to create.
        - `**kwargs`: Role permissions as key-value pairs (e.g., `can_create_group=True`).

        **Returns:**
        - `JsonResponse`:
          - **Success (201)**: `{'name': str, 'status': 201}`
          - **Error (400)**: `{'status': 400, 'reason': 'Creation of role "{role_name}" failed.'}`
          - **Error (403)**: `{'status': 403, 'reason': 'Session is not valid'}`

        **Example:**
        ```
        POST /api/v1/user/role/create
        {
            "role_name": "moderator",
            "can_create_group": true,
            "can_manage_users": false
        }
        ```
        """
        logger.info('Creating new role')
        role = Roles.from_keys(**kwargs)
        return AuthApi().create_role(State.state, role_name=role_name, roles=role)

    @role_blueprint.post('/assign')
    @json_endpoint
    @require_session
    @require_user_role(Roles.can_create_role)
    async def assign_role(session_user: User, role_name: str, user_uuid: str) -> WebResponse:
        """
        ### Assign a role to a user

        *Docstring generated by AI.*

        Assigns the specified role to the user with the given UUID. Requires an active session.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).
        - `role_name` (`str`): The name of the role to assign.
        - `user_uuid` (`str`): The UUID of the user to assign the role to.

        **Returns:**
        - `WebResponse`:
          - **Success (200)**: Empty response body
          - **Error (403)**: `{'status': 403, 'reason': 'Session is not valid'}`
          - **Error (404)**: `{'status': 404, 'reason': 'User does not exist'}` or
          `{'status': 404, 'reason': 'Role does not exist'}`

        **Example:**
        ```
        POST /api/v1/user/role/assign
        {
            "role_name": "moderator",
            "user_uuid": "12345678-1234-5678-9012-123456789012"
        }
        ```
        """
        logger.info(f'Assigning {role_name} to user {user_uuid}')
        return AuthApi().assign_role(State.state, role_name=role_name, user_uuid=uuid.UUID(hex=user_uuid))

    # required to bootstrap server
    @local.post('/create/bot')
    @url_endpoint
    @require_local
    async def local_create_bot() -> JsonResponse:
        """
        ### Create a new bot user (Local only)

        *Docstring generated by AI.*

        Creates a new user and links a bot user to it, returning the bot token.
        This endpoint is only available for local requests (internal server bootstrapping).

        **Returns:**
        - `JsonResponse`:
          - **Success (201)**: `{'bot_token': str, 'status': 201}`
          - **Error (400)**: `{'status': 400, 'reason': 'An internal error occurred'}`
          - **Error (403)**: `{'status': 403, 'reason': 'Access denied - local access only'}`

        **Example:**
        ```
        POST /api/local/user/create/bot
        ```
        """
        logger.info('Creating new bot user (Local)')
        return AuthApi().create_new_user_bot(state=State.state)

    @local_role_blueprint.post('/create')
    @json_endpoint
    @require_local
    @require_session
    async def local_create_role(session_user: User, role_name: str, **kwargs) -> JsonResponse:
        """
        ### Create a new role (Local only)

        *Docstring generated by AI.*

        Creates a new role with the specified name and role permissions.
        This endpoint is only available for local requests (internal server administration).

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).
        - `role_name` (`str`): The name of the role to create.
        - `**kwargs`: Role permissions as key-value pairs (e.g., `can_create_group=True`).

        **Returns:**
        - `JsonResponse`:
          - **Success (201)**: `{'name': str, 'status': 201}`
          - **Error (400)**: `{'status': 400, 'reason': 'Creation of role "{role_name}" failed.'}`
          - **Error (401)**: `{'status': 401, 'reason': 'Session is not valid'}`
          - **Error (403)**: `{'status': 403, 'reason': 'Access denied: only local'}`

        **Example:**
        ```
        POST /api/local/user/role/create
        {
            "role_name": "admin",
            "can_create_group": true,
            "can_manage_users": true
        }
        ```
        """
        logger.info('Creating new role (Local)')
        role = Roles.from_keys(**kwargs)
        return AuthApi().create_role(State.state, role_name=role_name, roles=role)

    @local_role_blueprint.post('/assign')
    @json_endpoint
    @require_local
    @require_session
    async def local_assign_role(session_user: User, role_name: str, user_uuid: str) -> WebResponse:
        """
        ### Assign a role to a user (Local only)

        *Docstring generated by AI.*

        Assigns the specified role to the user with the given UUID.
        This endpoint is only available for local requests (internal server administration).

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).
        - `role_name` (`str`): The name of the role to assign.
        - `user_uuid` (`str`): The UUID of the user to assign the role to.

        **Returns:**
        - `WebResponse`:
          - **Success (200)**: Empty response body
          - **Error (401)**: `{'status': 401, 'reason': 'Session is not valid'}`
          - **Error (403)**: `{'status': 403, 'reason': 'Access denied - local access only'}`
          - **Error (404)**: `{'status': 404, 'reason': 'User does not exist'}` or
          `{'status': 404, 'reason': 'Role does not exist'}`

        **Example:**
        ```
        POST /api/local/user/role/assign
        {
            "role_name": "admin",
            "user_uuid": "12345678-1234-5678-9012-123456789012"
        }
        ```
        """
        logger.info(f'Assigning {role_name} to user {user_uuid} (Local)')
        return AuthApi().assign_role(State.state, role_name=role_name, user_uuid=uuid.UUID(hex=user_uuid))

    api.register_blueprint(role_blueprint)
    local.register_blueprint(local_role_blueprint)


def define_group(api: Blueprint, local: Blueprint, html: Blueprint):
    @api.post('/create/permission')
    @json_endpoint
    @require_session
    @require_user_role(Roles.can_create_group)
    async def create_group_permission(session_user: User, permission_name: str, **kwargs) -> JsonResponse:
        """
        ### Create a new group permission

        *Docstring generated by AI.*

        Creates a new group permission with the specified name and permission settings.
        Requires an active session and the `can_create_group` role.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).
        - `permission_name` (`str`): The name of the permission to create.
        - `**kwargs`: Permission settings as key-value pairs (e.g., `can_read=True`, `can_write=False`).

        **Returns:**
        - `JsonResponse`:
          - **Success (201)**: `{'name': str, 'status': 201}`
          - **Error (400)**: `{'status': 400, 'reason': 'Creation of permission "{permission_name}" failed.'}`
          - **Error (401)**: `{'status': 403, 'reason': 'Session is not valid'}`
          - **Error (403)**: `{'status': 403, 'reason': 'User does not have role'}`

        **Example:**
        ```
        POST /api/v1/group/create/permission
        {
            "permission_name": "read_access",
            "can_read": true,
            "can_write": false,
            "can_delete": false
        }
        ```
        """
        logger.info(f"Creating new group permission '{permission_name}'")
        permission = Permissions.from_keys(default_if_key_not_present=False, **kwargs)
        return AuthApi().create_group_permission(State.state, permission_name=permission_name, permissions=permission)

    @api.post('/create')
    @json_endpoint
    @require_session
    @require_user_role(Roles.can_create_group)
    async def create_group(session_user: User, group_name: str, permissions: str) -> JsonResponse:
        """
        ### Create a new group

        *Docstring generated by AI.*

        Creates a new group with the specified name and associated permissions.
        Requires an active session and the `can_create_group` role.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).
        - `group_name` (`str`): The name of the group to create.
        - `permissions` (`str`): The name of the permission group to associate with this group.

        **Returns:**
        - `JsonResponse`:
          - **Success (201)**: `{'name': str, 'status': 201}`
          - **Error (400)**: `{'status': 400, 'reason': 'Creation of group "{group_name}" failed.'}`
          - **Error (401)**: `{'status': 401, 'reason': 'Session is not valid'}`
          - **Error (403)**: `{'status': 403, 'reason': 'User does not have role'}`
          - **Error (404)**: `{'status': 404, 'reason': 'Permission group does not exist'}`

        **Example:**
        ```
        POST /api/v1/group/create
        {
            "group_name": "editors",
            "permissions": "edit_permissions"
        }
        ```
        """
        logger.info(f'Creating new group {group_name} with permissions {permissions}')
        return AuthApi().create_group(state=State.state, group_name=group_name, permission_group=permissions)

    @api.post('/join')
    @json_endpoint
    @require_session
    async def join_group(session_user: User, group_name: str) -> WebResponse:
        """
        ### Join a group

        *Docstring generated by AI.*

        Adds the authenticated user to the specified group. Requires an active session.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).
        - `group_name` (`str`): The name of the group to join.

        **Returns:**
        - `WebResponse`:
          - **Success (200)**: Empty response body
          - **Error (403)**: `{'status': 403, 'reason': 'Session is not valid'}`
          - **Error (404)**: `{'status': 404, 'reason': 'Group does not exist'}`
          - **Error (400)**: `{'status': 400, 'reason': 'Group assignment failed'}`

        **Example:**
        ```
        POST /api/v1/group/join
        {
            "group_name": "editors"
        }
        ```
        """
        logger.info(f'User {session_user.id} is joining group {group_name}')
        return AuthApi().join_group(state=State.state, user=session_user, group_name=group_name)

    @api.post('/leave')
    @json_endpoint
    @require_session
    async def leave_group(session_user: User, group_name: str) -> WebResponse:
        """
        ### Leave a group

        *Docstring generated by AI.*

        Removes the authenticated user from the specified group. Requires an active session.

        **Args:**
        - `session_user` (`User`): The authenticated user (automatically injected by `@require_session`).
        - `group_name` (`str`): The name of the group to leave.

        **Returns:**
        - `WebResponse`:
          - **Success (200)**: Empty response body
          - **Error (403)**: `{'status': 403, 'reason': 'Session is not valid'}`
          - **Error (404)**: `{'status': 404, 'reason': 'Group does not exist'}`

        **Example:**
        ```
        POST /api/v1/group/leave
        {
            "group_name": "editors"
        }
        ```
        """
        logger.info(f'User {session_user.id} is leaving group {group_name}')
        return AuthApi().leave_group(state=State.state, user=session_user, group_name=group_name)

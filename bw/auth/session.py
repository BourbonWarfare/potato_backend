import secrets
import logging

from sqlalchemy import insert, delete, select

from bw.state import State
from bw.models.auth import Session, User, DiscordOAuthCode, TOKEN_LENGTH
from bw.error import SessionExpired, NoAccessCodeFound


logger = logging.getLogger('bw.auth')


class SessionStore:
    def expire_session_from_user(self, state: State, user: User):
        """
        ### Expire session for a user

        Expires (removes) session associated with the given user.

        *Docstring generated by AI.*

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `user` (`User`): The user whose session should be expired.

        **Returns:**
        - `None`: This method does not return a value.

        **Example:**
        ```python
        SessionStore().expire_session_from_user(state, user)
        # Session is expired for the user
        ```
        """
        with state.Session.begin() as session:
            query = delete(Session).where(Session.user_id == user.id)
            session.execute(query)

    def start_user_session(self, state: State, user: User) -> dict:
        """
        ### Start a new human session for a user

        Starts a new human session for the given user, does not expire any existing sessions.

        *Docstring generated by AI.*

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `user` (`User`): The user for whom to start a new session.

        **Raises:**
        - `SessionExpired`: If the session could not be created.

        **Returns:**
        - `dict`: A dictionary containing session-specific information with keys 'session_token' and
        'expire_time'.

        **Example:**
        ```python
        session_data = SessionStore().start_user_session(state, user)
        # {'session_token': 'abc123...', 'expire_time': '2024-12-31T23:59:59'}
        ```
        """
        token = secrets.token_urlsafe()[:TOKEN_LENGTH]
        with state.Session.begin() as session:
            query = (
                insert(Session)
                .values(user_id=user.id, token=token, expire_time=Session.human_session_length())
                .returning(Session.expire_time)
            )
            expire_time = session.scalar(query)

        if expire_time is None:
            raise SessionExpired()

        return {'session_token': token, 'expire_time': str(expire_time)}

    def start_api_session(self, state: State, user: User) -> dict:
        """
        ### Start a new API session for a user

        Starts a new API session for the given user, expiring any existing sessions.
        Used for bots to communicate with the API; they have a shorter-lived session.

        *Docstring generated by AI.*

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `user` (`User`): The user for whom to start a new session.

        **Raises:**
        - `SessionExpired`: If the session could not be created.

        **Returns:**
        - `dict`: A dictionary containing session-specific information with keys 'session_token' and
        'expire_time'.

        **Example:**
        ```python
        session_data = SessionStore().start_api_session(state, user)
        # {'session_token': 'xyz789...', 'expire_time': '2024-12-25T12:00:00'}
        ```
        """
        self.expire_session_from_user(state, user)

        token = secrets.token_urlsafe()[:TOKEN_LENGTH]
        with state.Session.begin() as session:
            query = (
                insert(Session)
                .values(user_id=user.id, token=token, expire_time=Session.api_session_length())
                .returning(Session.expire_time)
            )
            expire_time = session.scalar(query)

        if expire_time is None:
            raise SessionExpired()

        return {'session_token': token, 'expire_time': str(expire_time)}

    def is_session_active(self, state: State, session_token: str) -> bool:
        """
        ### Check if a session is active

        Checks if a session with the given token is currently active (not expired).

        *Docstring generated by AI.*

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `session_token` (`str`): The session token to check.

        **Returns:**
        - `bool`: True if the session is active, False otherwise.

        **Example:**
        ```python
        is_active = SessionStore().is_session_active(state, 'token123')
        # True (if session is valid and not expired)
        # False (if session doesn't exist or is expired)
        ```
        """
        with state.Session.begin() as session:
            # First check if session exists at all
            query = select(Session).where(Session.token == session_token)
            session_record = session.execute(query).first()

            if session_record is None:
                logger.info(f'Could not find existing session record for token {session_token}')
                return False

            session_obj = session_record[0]

            # Check if session is expired
            query = select(Session.now())
            current_time = session.scalar(query)

            if current_time > session_obj.expire_time:
                logger.info(f'Session for token {session_token} is expired {(session_obj.expire_time - current_time)}')

            return current_time <= session_obj.expire_time

    def get_user_from_session_token(self, state: State, session_token: str) -> User:
        """
        ### Retrieve user from session token

        Retrieves the user associated with the given session token, if the session is active.

        *Docstring generated by AI.*

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `session_token` (`str`): The session token to look up.

        **Raises:**
        - `SessionExpired`: If the session token is not found or is expired.

        **Returns:**
        - `User`: The user associated with the session token.

        **Example:**
        ```python
        user = SessionStore().get_user_from_session_token(state, 'token123')
        # User object with id, uuid, creation_date, etc.
        # Raises SessionExpired if token is invalid or expired
        ```
        """
        with state.Session.begin() as session:
            # First get the session record
            query = select(Session).where(Session.token == session_token)
            session_record = session.execute(query).first()

            if session_record is None:
                logger.info(f'Could not find existing session record for token {session_token}')
                raise SessionExpired()

            session_obj = session_record[0]

            # Check if session is expired
            query = select(Session.now())
            current_time = session.scalar(query)

            if current_time > session_obj.expire_time:
                logger.info(f'Session for token {session_token} is expired {(session_obj.expire_time - current_time)}')
                raise SessionExpired()

            # Get the user
            query = select(User).where(User.id == session_obj.user_id)
            user = session.execute(query).one()[0]
            session.expunge(user)
        return user

    def register_discord_oauth_code(self, state: State, access_code: str, access_code_state: str):
        """
        ### Register Discord OAuth access code

        Stores access code in the database to be queried later. The code has a short expiry time.

        *Docstring generated by AI.*

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `access_code` (`str`): The access code that the OAuth flow provided.
        - `access_code_state` (`str`): The state parameter that the OAuth flow provided.

        **Returns:**
        - `None`: This method does not return a value.

        **Example:**
        ```python
        SessionStore().register_discord_oauth_code(state, 'oauth_code_123', 'state_abc')
        # Code is stored in database with expiry time
        ```
        """
        with state.Session.begin() as session:
            model = DiscordOAuthCode(state=access_code_state, code=access_code)
            session.add(model)
            session.commit()

    def get_discord_oauth_code(self, state: State, access_code_state: str) -> str:
        """
        ### Get Discord OAuth access code

        Retrieves and deletes the access code associated with the given state parameter from the
        OAuth flow. The code is only valid if it hasn't expired.

        *Docstring generated by AI.*

        **Async:** No

        **Args:**
        - `state` (`State`): The application state containing the database connection.
        - `access_code_state` (`str`): The state parameter that the OAuth flow provided.

        **Raises:**
        - `NoAccessCodeFound`: If the access code for the given state doesn't exist or has expired.

        **Returns:**
        - `str`: The access code associated with the state parameter.

        **Example:**
        ```python
        code = SessionStore().get_discord_oauth_code(state, 'state_abc')
        # 'oauth_code_123'
        # Raises NoAccessCodeFound if code doesn't exist or expired
        ```
        """
        with state.Session.begin() as session:
            query = select(DiscordOAuthCode.code, DiscordOAuthCode.expire_time).where(DiscordOAuthCode.state == access_code_state)
            result = session.execute(query).one_or_none()

            if result is None:
                raise NoAccessCodeFound()

            query = select(Session.now())
            current_time = session.scalar(query)
            if current_time > result.expire_time:
                raise NoAccessCodeFound()

            query = delete(DiscordOAuthCode).where(DiscordOAuthCode.state == access_code_state)
            session.execute(query)

            session.commit()
            return result.code
